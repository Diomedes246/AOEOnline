<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Isometric Multiplayer RTS</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:black; }
canvas { display:block; }
#hud {
  position:fixed;
  top:10px; left:10px;
  color:white;
  font-family:monospace;
  background:rgba(0,0,0,0.5);
  padding:6px;
}
#panel {
  position:fixed;
  bottom:20px;
  left:20px;
  width:220px;
  height:120px;
  background:rgba(30,30,30,0.85);
  border:2px solid #888;
  padding:10px;
  color:white;
  font-family:monospace;
  display:none;
}

#buildBtn {
  width:100%;
  height:40px;
  margin-top:10px;
  background:#444;
  color:white;
  border:1px solid #aaa;
  cursor:pointer;
}
#buildBtn:hover { background:#666; }
#buildBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
</style>
</head>

<body>
<canvas id="game"></canvas>
<div id="hud"></div>

<div id="panel">
  <div>Unit Selected</div>
  <button id="buildBtn">Place Building</button>
</div>

<div id="buildingPanel" style="display:none; position:fixed; bottom:20px; left:20px; width:220px; height:120px; background:rgba(30,30,30,0.85); border:2px solid #888; padding:10px; color:white; font-family:monospace;">
  <div>Building Selected</div>
  <button id="createUnitBtn">Create Unit</button>
</div>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");
const panel = document.getElementById("panel");
const buildBtn = document.getElementById("buildBtn");
const socket = io();

let mySid = null;
socket.on("connect", ()=> mySid = socket.id);

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();



/* ================= CAMERA ================= */
let camera = {x:0,y:0};
const camSpeed = 12;
const keys = {};
document.addEventListener("keydown", e=>keys[e.key]=true);
document.addEventListener("keyup", e=>keys[e.key]=false);


/* ================= PLAYER SPRITES ================= */

const SPRITE_W = 256;
const SPRITE_H = 256;
const DIRECTIONS = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337];
const IDLE_FRAMES = 24;
const WALK_FRAMES = 24;
const ANIM_SPEED = 0.3;

const playerSprites = {
  idle: {},
  walk: {},
  idleshadow:{},
  walkshadow:{},
};

function pad(num, length=3) { return num.toString().padStart(length, "0"); }
function padFrame(num, length=4) { return num.toString().padStart(length, "0"); }



for (const deg of DIRECTIONS) {
  const d = pad(deg);

  playerSprites.idle[d] = [];
  playerSprites.walk[d] = [];
  playerSprites.idleshadow[d] = [];
  playerSprites.walkshadow[d] = [];

  // Idle frames
  for (let i = 1; i <= IDLE_FRAMES; i++) {
    const img = new Image();
    img.src = `static/Idle/Body/${d}/Idle_Body_${d}_${padFrame(i)}.png`;
    playerSprites.idle[d].push(img);
    const imgshadow = new Image();
    imgshadow.src = `static/Idle/Shadow/${d}/Idle_Shadow_${d}_${padFrame(i)}.png`;
    playerSprites.idleshadow[d].push(imgshadow);
  }

  // Walk frames
  for (let i = 1; i <= WALK_FRAMES; i++) {
    const img = new Image();
    img.src = `static/Run/Body/${d}/Run_Body_${d}_${padFrame(i)}.png`;
    playerSprites.walk[d].push(img);
    const imgshadow = new Image();
    imgshadow.src = `static/Run/Shadow/${d}/Run_Shadow_${d}_${padFrame(i)}.png`;
    playerSprites.walkshadow[d].push(imgshadow);
  }
}



function getNearestDegree(dx, dy) {
  const angle =
    (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;

  let best = DIRECTIONS[0];
  let minDiff = 999;

  for (const d of DIRECTIONS) {
    let diff = Math.abs(d - angle);
    diff = Math.min(diff, 360 - diff);
    if (diff < minDiff) {
      minDiff = diff;
      best = d;
    }
  }

  return best.toString().padStart(3, "0");
}

function getDirKey(vx, vy) {
    if (vx === 0 && vy === 0) return "000"; // idle

    // Map-space conversion for isometric screen
    // screenX = mapX - mapY
    // screenY = (mapX + mapY)/2
    // Solve for map-space deltas:
    const map_dx = -vx - vy; // invert X to swap east/west
    const map_dy = -vy - vx; // Y-up for north

    // Angle in degrees, Y-up
    const angle = (Math.atan2(-map_dy, map_dx) * 180 / Math.PI + 360) % 360;

    const dirs = [0,22,45,67,90,112,135,157,180,202,225,247,270,292,315,337];

    let closest = dirs[0];
    let minDiff = 360;

    for (const d of dirs) {
        let diff = Math.abs(d - angle);
        diff = Math.min(diff, 360 - diff);
        if (diff < minDiff) {
            minDiff = diff;
            closest = d;
        }
    }

    return closest.toString().padStart(3,"0");
}




/* ================= LOCAL UNITS ================= */
let myUnits = [
  {
    x: 0, y: 0,
    tx: 0, ty: 0,
    selected: false,
    targetResource: null,
    anim: "idle",
    frame: 0,
    dir: "000", // ← use string here
    lastX: 0,
    lastY: 0
  }
];

function getDirection(dx, dy) {
  const angle = Math.atan2(dy, dx); // -PI to PI
  let dir = Math.round((angle / (2 * Math.PI)) * DIRECTIONS);
  if (dir < 0) dir += DIRECTIONS;
  return dir % DIRECTIONS;
}

let players = {};
let buildings = []; // list of {x, y, owner}





let otherPlayersUnits = {}; // sid -> [{x,y,anim,frame,dir}, ...]

/* ================= TILE ================= */
const tile = new Image();
tile.src = "static/grassbackground.png";
const TILE_W = 5178;
const TILE_H = 3009;
const HALF_W = TILE_W/2.1;
const HALF_H = TILE_H/2.1;

/* ================= RESOURCES ================= */
const RESOURCE_RADIUS = 40;
const HARVEST_TIME = 10000; // ms

let resources = [];          // {id, x, y}
let harvesting = null;       // {resourceId, startTime}
const resourceImg = new Image();
resourceImg.src = "static/resource.png";
const RES_W = 48;
const RES_H = 48;

let resourceCount = 0;
let hoveredResource = null;

let hoveredPlayerSid = null;  

function spawnResources(){
  const cols = 69;
  const rows = 53;
  const spacing = 180;
  let id = 0;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(Math.random() < 0.035){
        resources.push({
          id: id++,
          x: (c - r) * spacing,
          y: (c + r) * spacing / 2
        });
      }
    }
  }
}
spawnResources();

/* ================= RTS INPUT ================= */
let selecting=false;
let selectStart={x:0,y:0};
let mouse={x:0,y:0};
let buildMode=false;
let localBuildingPlaced=false;

canvas.addEventListener("mousemove", e=>{
  mouse.x = e.clientX;
  mouse.y = e.clientY;

  const wx = camera.x + mouse.x - canvas.width/2;
  const wy = camera.y + mouse.y - canvas.height/2;

  hoveredResource = null;
  hoveredPlayerSid = null;

  // Resource hover (priority 1)
  for(const r of resources){
    if(Math.hypot(r.x-wx, r.y-wy) < RESOURCE_RADIUS){
      hoveredResource = r;
      canvas.style.cursor = "pointer";
      return;
    }
  }

  // Player hover (priority 2)
  for(const sid in players){
    if(sid === mySid) continue;
    const p = players[sid];
    if(Math.hypot(p.x-wx, p.y-wy) < 20){
      hoveredPlayerSid = sid;
      canvas.style.cursor = "crosshair";
      return;
    }
  }

  canvas.style.cursor = "default";
});



canvas.addEventListener("mousedown", e => {
    if (e.button === 0) { // left click
        let clickedResource = null;  // <-- add this
        let clickedPlayerSid = null; // <-- add this

        // existing build placement
        if (buildMode && !localBuildingPlaced) {
            const wx = camera.x + mouse.x - canvas.width/2;
            const wy = camera.y + mouse.y - canvas.height/2;
            buildings.push({x: wx, y: wy, owner: mySid, selected: false, queue: []});
            localBuildingPlaced = true;
            buildMode = false;
            buildBtn.disabled = true;
            socket.emit("place_building", {x: wx, y: wy});
            return;
        }

        selecting = true;
        selectStart.x = mouse.x;
        selectStart.y = mouse.y;

// Deselect all units and buildings first
for (const u of myUnits) u.selected = false;
for (const b of buildings) b.selected = false;

let clickedBuilding = null;
for (const b of buildings) {
    const bx = canvas.width/2 + b.x - camera.x;
    const by = canvas.height/2 + b.y - camera.y;
    const BUILD_RADIUS = 50;
    if (Math.hypot(mouse.x - bx, mouse.y - by) < BUILD_RADIUS) {
        clickedBuilding = b;
        break;
    }
}

if (clickedBuilding && clickedBuilding.owner === mySid) {
    clickedBuilding.selected = true;
    panel.style.display = "none";
    buildingPanel.style.display = "block"; // show building panel
} else {
    buildingPanel.style.display = "none";
}
}

});


canvas.addEventListener("mouseup", e=>{
  if(e.button===0){
    selecting=false;
    const x1=Math.min(selectStart.x,mouse.x);
    const y1=Math.min(selectStart.y,mouse.y);
    const x2=Math.max(selectStart.x,mouse.x);
    const y2=Math.max(selectStart.y,mouse.y);
    for(const u of myUnits){
      const sx=canvas.width/2+u.x-camera.x;
      const sy=canvas.height/2+u.y-camera.y;
      u.selected=(sx>=x1&&sx<=x2 && sy>=y1&&sy<=y2);
    }
  } 
  if(e.button===2){
    const wx=camera.x+mouse.x-canvas.width/2;
    const wy=camera.y+mouse.y-canvas.height/2;

    let clickedResource = null;
    let clickedPlayerSid = null;

    for(const r of resources){
      if(Math.hypot(r.x-wx,r.y-wy) < RESOURCE_RADIUS){
        clickedResource = r;
        break;
      }
    }

    if(!clickedResource){
      for(const sid in players){
        if(sid === mySid) continue;
        const p = players[sid];
        if(Math.hypot(p.x-wx,p.y-wy) < 20){
          clickedPlayerSid = sid;
          break;
        }
      }
    }

    for(const u of myUnits){
      if(u.selected){
        if(clickedResource){
          u.tx = clickedResource.x;
          u.ty = clickedResource.y;
          u.targetResource = clickedResource.id;
          targetPlayerSid = null;
        }
        else if(clickedPlayerSid){
          u.tx = players[clickedPlayerSid].x;
          u.ty = players[clickedPlayerSid].y;
          targetPlayerSid = clickedPlayerSid;
          u.targetResource = null;
        }
else {
    const selectedUnits = myUnits.filter(u => u.selected);
    const spreadRadius = 40; // distance between units
    const count = selectedUnits.length;
    
    selectedUnits.forEach((unit, idx) => {
        // Arrange units in a circle around the target point
        const angle = (idx / count) * Math.PI * 2;
        unit.tx = wx + Math.cos(angle) * spreadRadius;
        unit.ty = wy + Math.sin(angle) * spreadRadius;
        unit.targetResource = null;
        targetPlayerSid = null;
        harvesting = null;
    });
}

      }
    }
  }
});

canvas.addEventListener("contextmenu", e=>e.preventDefault());

const createUnitBtn = document.getElementById("createUnitBtn");
createUnitBtn.onclick = () => {
    const selectedBuilding = buildings.find(b => b.selected && b.owner === mySid);
    if (!selectedBuilding) return;

    const radius = BUILD_W / 2 + 30; // spawn outside building
    const unitsToSpawn = 1; // you can increase this if creating multiple units at once

    // Count how many units are already around this building
    const existingUnits = myUnits.filter(u => Math.hypot(u.x - selectedBuilding.x, u.y - selectedBuilding.y) < radius + 20);
    const startIndex = existingUnits.length;

    for (let i = 0; i < unitsToSpawn; i++) {
        const idx = startIndex + i;
        const angle = (idx * 45) * Math.PI / 180; // spread units 45° apart
        const spawnX = selectedBuilding.x + Math.cos(angle) * radius;
        const spawnY = selectedBuilding.y + Math.sin(angle) * radius;

        const newUnit = {
            x: spawnX,
            y: spawnY,
            tx: spawnX,
            ty: spawnY,
            selected: false,
            targetResource: null,
            anim: "idle",
            frame: 0,
            dir: "000",
            lastX: spawnX,
            lastY: spawnY
        };

        myUnits.push(newUnit);
    }
};



buildBtn.onclick = ()=>{ if(!localBuildingPlaced) buildMode=true; };

/* ================= COMBAT ================= */
const ATTACK_RANGE = 80;
const DPS = 10; // damage per second

let targetPlayerSid = null;

let playerHealth = {};
const MAX_HEALTH = 100;

/* ================= SOCKET STATE ================= */
socket.on("state", state => {
  players = state.players || {};
  buildings = state.buildings || [];

  // Extract other players' units
  otherPlayersUnits = {};
  for (const sid in players) {
    if (sid === mySid) continue;
    otherPlayersUnits[sid] = players[sid].units || [];
  }

  // Preserve selection of buildings
  const prevSelected = new Set(buildings.filter(b => b.selected).map(b => b.owner + "_" + b.x + "_" + b.y));
  for(const b of buildings){
    const key = b.owner + "_" + b.x + "_" + b.y;
    b.selected = prevSelected.has(key);
  }
});


/* ================= UPDATE ================= */
function update(){
  if(keys.w) camera.y-=camSpeed;
  if(keys.s) camera.y+=camSpeed;
  if(keys.a) camera.x-=camSpeed;
  if(keys.d) camera.x+=camSpeed;

  const speed=2;
  for(const u of myUnits){
    const dx=u.tx-u.x;
    const dy=u.ty-u.y;
    const d=Math.hypot(dx,dy);
    if(d>1){ u.x+=dx/d*speed; u.y+=dy/d*speed; }
  }

  for (const u of myUnits) {
      // Compute movement vector
      const dx = u.tx - u.x;
      const dy = u.ty - u.y;
      const dist = Math.hypot(dx, dy);

      const speed = 4;
      const deadzone = 1.5; // pixels

      if (dist > deadzone) {
          // Move towards target
          u.x += (dx / dist) * Math.min(speed, dist);
          u.y += (dy / dist) * Math.min(speed, dist);
      } else {
          // Snap to target
          u.x = u.tx;
          u.y = u.ty;
      }

      // Compute velocity for animation
      const vx = u.x - u.lastX;
      const vy = u.y - u.lastY;
      const moving = Math.hypot(vx, vy) > 0.2; // still a small threshold

      if (moving) {
          u.dir = getDirKey(vx, vy);
          u.anim = "walk";
          u.frame += ANIM_SPEED;
          if (u.frame >= WALK_FRAMES) u.frame = 0;
      } else {
          u.anim = "idle";
          u.frame += ANIM_SPEED;
          if (u.frame >= IDLE_FRAMES) u.frame = 0;
      }

      u.lastX = u.x;
      u.lastY = u.y;
  }





  for(const u of myUnits){
    if(u.targetResource !== null){
      const r = resources.find(r=>r.id===u.targetResource);
      if(!r) continue;

      const dist = Math.hypot(u.x - r.x, u.y - r.y);

      if(dist < RESOURCE_RADIUS){
        if(!harvesting){
          harvesting = {
            resourceId: r.id,
            startTime: performance.now()
          };
        } else if(performance.now() - harvesting.startTime >= HARVEST_TIME){
            resources = resources.filter(rr=>rr.id !== r.id);
            resourceCount++;
            harvesting = null;
            u.targetResource = null
        }
      } else {
        harvesting = null; // walked away
      }
    }
  }

  if(targetPlayerSid && players[targetPlayerSid]){
    const p = players[targetPlayerSid];
    const u = myUnits[0];

    const dist = Math.hypot(u.x - p.x, u.y - p.y);

    if(dist < ATTACK_RANGE){
      playerHealth[targetPlayerSid] -= DPS / 60;
      if(playerHealth[targetPlayerSid] < 0){
        playerHealth[targetPlayerSid] = 0;
      }
    }
  }


  socket.emit("update",{x:myUnits[0].x,y:myUnits[0].y});


  const unitStates = myUnits.map(u => ({
    x: u.x,
    y: u.y,
    anim: u.anim,
    frame: u.frame,
    dir: u.dir
  }));
  socket.emit("update_units", { units: unitStates });
  
}

// Update all myUnits
const unitStates = myUnits.map(u => ({
  x: u.x,
  y: u.y,
  anim: u.anim,
  frame: u.frame,
  dir: u.dir
}));

socket.emit("update_units", { units: unitStates });




/* ================= BACKGROUND ================= */
function drawBackground(){
  const cx=canvas.width/2;
  const cy=canvas.height/2;
  const baseCol=Math.floor(camera.x/HALF_W);
  const baseRow=Math.floor(camera.y/HALF_H);
  const range=4;

  for(let r=-range;r<=range;r++){
    for(let c=-range;c<=range;c++){
      const col=baseCol+c;
      const row=baseRow+r;
      const wx=(col-row)*HALF_W;
      const wy=(col+row)*HALF_H;
      ctx.drawImage(tile, cx+wx-camera.x, cy+wy-camera.y);
    }
  }
}

/* ================= DRAW ================= */
const buildingImg = new Image();
buildingImg.src = "static/building.png";
const BUILD_W = 506;
const BUILD_H = 370;

function draw(){
  update();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();

    // Draw resources
  for(const r of resources){
    const x = canvas.width/2 + r.x - camera.x;
    const y = canvas.height/2 + r.y - camera.y;
    ctx.drawImage(resourceImg, x-RES_W/2, y-RES_H/2, RES_W, RES_H);
  }

  if(harvesting){
    const r = resources.find(r=>r.id===harvesting.resourceId);
    if(r){
      const progress = Math.min(
        1,
        (performance.now() - harvesting.startTime) / HARVEST_TIME
      );
      const x = canvas.width/2 + r.x - camera.x;
      const y = canvas.height/2 + r.y - camera.y - 40;

      ctx.fillStyle = "black";
      ctx.fillRect(x-30, y, 60, 6);
      ctx.fillStyle = "lime";
      ctx.fillRect(x-30, y, 60 * progress, 6);
    }
}

// Hover outline
if(hoveredResource){
  const x = canvas.width/2 + hoveredResource.x - camera.x;
  const y = canvas.height/2 + hoveredResource.y - camera.y;

  ctx.strokeStyle = "yellow";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, RESOURCE_RADIUS, 0, Math.PI * 2);
  ctx.stroke();
}


  // Draw buildings
  for(const b of buildings){
    const bx = canvas.width/2 + b.x - camera.x;
    const by = canvas.height/2 + b.y - camera.y;
    ctx.drawImage(buildingImg, bx-BUILD_W/2, by-BUILD_H/2, BUILD_W, BUILD_H);
  }



  // Draw other players
for (const sid in otherPlayersUnits) {
  const units = otherPlayersUnits[sid];
  for (const u of units) {
    const x = canvas.width/2 + u.x - camera.x;
    const y = canvas.height/2 + u.y - camera.y;

    const frames = u.anim === "walk" ? playerSprites.walk[u.dir] : playerSprites.idle[u.dir];
    const shadowFrames = u.anim === "walk" ? playerSprites.walkshadow[u.dir] : playerSprites.idleshadow[u.dir];

    const imgShadow = shadowFrames[Math.floor(u.frame)];
    const img = frames[Math.floor(u.frame)];

    if(imgShadow && imgShadow.complete) ctx.drawImage(imgShadow, x-SPRITE_W/2, y-SPRITE_H/2, SPRITE_W, SPRITE_H);
    if(img && img.complete) ctx.drawImage(img, x-SPRITE_W/2, y-SPRITE_H/2, SPRITE_W, SPRITE_H);

    // Draw player name
    ctx.fillStyle="white";
    ctx.font="12px monospace";
    ctx.textAlign="center";
    ctx.fillText(sid.slice(0,5), x, y-40);

    // Health bar (optional)
    const hp = playerHealth[sid] ?? MAX_HEALTH;
    const barW = 30;
    const barH = 4;
    ctx.fillStyle = "black";
    ctx.fillRect(x-barW/2, y-52, barW, barH);
    ctx.fillStyle = "lime";
    ctx.fillRect(x-barW/2, y-52, barW*(hp/MAX_HEALTH), barH);
  }
}

  // Hover outline for other players
  if(hoveredPlayerSid && players[hoveredPlayerSid]){
    const p = players[hoveredPlayerSid];
    const x = canvas.width/2 + p.x - camera.x;
    const y = canvas.height/2 + p.y - camera.y;

    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.rect(x-14, y-14, 28, 28);
    ctx.stroke();
    ctx.setLineDash([]);
  }


for (const u of myUnits) {
  const x = canvas.width / 2 + u.x - camera.x;
  const y = canvas.height / 2 + u.y - camera.y;
  ctx.fillStyle="white";
  ctx.font="12px monospace";
  ctx.textAlign="center";
  ctx.fillText("YOU", x, y-40);

  const framesshadow =
    u.anim === "walk"
      ? playerSprites.walkshadow[u.dir]
      : playerSprites.idleshadow[u.dir];

  const imgshadow = framesshadow[Math.floor(u.frame)];

  if (imgshadow && imgshadow.complete) {
    ctx.drawImage(
      imgshadow,
      x - SPRITE_W / 2,
      y - SPRITE_H / 2,
      SPRITE_W,
      SPRITE_H
    );
  }


  const frames =
    u.anim === "walk"
      ? playerSprites.walk[u.dir]
      : playerSprites.idle[u.dir];

  const img = frames[Math.floor(u.frame)];

  if (img && img.complete) {
    ctx.drawImage(
      img,
      x - SPRITE_W / 2,
      y - SPRITE_H / 2,
      SPRITE_W,
      SPRITE_H
    );
  }





  if (u.selected) {
    ctx.strokeStyle = "yellow";
    ctx.beginPath();
    ctx.arc(x, y + SPRITE_H / 4, 18, 0, Math.PI * 2);
    ctx.stroke();
  }
}

for (const b of buildings) {
    const bx = canvas.width/2 + b.x - camera.x;
    const by = canvas.height/2 + b.y - camera.y;

    ctx.drawImage(buildingImg, bx-BUILD_W/2, by-BUILD_H/2, BUILD_W, BUILD_H);

    // Draw selection
    if (b.selected) {
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        ctx.strokeRect(bx-BUILD_W/2, by-BUILD_H/2, BUILD_W, BUILD_H);
        ctx.setLineDash([]);
    }
}

  // Draw building placement preview
  if(buildMode){
    ctx.globalAlpha=0.5;
    const wx=camera.x+mouse.x-canvas.width/2;
    const wy=camera.y+mouse.y-canvas.height/2;
    const bx=canvas.width/2+wx-camera.x;
    const by=canvas.height/2+wy-camera.y;
    ctx.drawImage(buildingImg, bx-BUILD_W/2, by-BUILD_H/2, BUILD_W, BUILD_H);
    ctx.globalAlpha=1;
  }

  // Draw selection box
  if(selecting){
    ctx.strokeStyle="white";
    ctx.setLineDash([5,5]);
    ctx.strokeRect(selectStart.x, selectStart.y, mouse.x-selectStart.x, mouse.y-selectStart.y);
    ctx.setLineDash([]);
  }

const selectedCount = myUnits.filter(u=>u.selected).length;
if (buildings.some(b=>b.selected)) {
    panel.style.display = "none";
} else {
    panel.style.display = selectedCount>0 ? "block" : "none";
}


  hud.innerText =
    `Camera: ${camera.x|0}, ${camera.y|0}
  Resources: ${resourceCount}
  Selected: ${selectedCount}`;

  requestAnimationFrame(draw);
}

tile.onload = draw;
</script>
</body>
</html>
