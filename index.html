  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="utf-8">
  <title>AOE Online</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; }
  canvas { display:block; }
  #hud {
    position:fixed;
    top:10px; left:10px;
    color:white;
    font-family:monospace;
    padding:6px;
  }
  #panel {
    position:fixed;
    bottom:20px;
    left:20px;
    width:220px;
    height:180px;
    background:rgba(30,30,30,0.85);
    border:2px solid #888;
    padding:10px;
    color:white;
    font-family:monospace;
    display:none;
  }

  #buildBtn {
    width:100%;
    height:40px;
    margin-top:10px;
    background:#444;
    color:white;
    border:1px solid #aaa;
    cursor:pointer;
  }
  #buildBtn:hover { background:#666; }
  #buildBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
  #mineBtn,
  #blacksmithBtn {
    width:100%;
    height:40px;
    margin-top:10px;
    background:#444;
    color:white;
    border:1px solid #aaa;
    cursor:pointer;
  }
  #mineBtn:hover,
  #blacksmithBtn:hover { background:#666; }
  #mineBtn:disabled,
  #blacksmithBtn:disabled { background:#222; color:#777; cursor:not-allowed; }

  #questLogToggle {
    position:fixed;
    top:110px;
    left:10px;
    display:flex;
    align-items:center;
    gap:8px;
    padding:8px 12px;
    border:2px solid #888;
    border-radius:6px;
    background:rgba(30,30,30,0.85);
    color:white;
    font-family:monospace;
    font-weight:normal;
    text-transform:none;
    letter-spacing:normal;
    cursor:pointer;
    transition:background 0.2s ease;
    z-index:1500;
  }
  #questLogToggle:hover {
    background:rgba(40,40,40,0.9);
  }
  #questLogToggle.active {
    background:rgba(50,50,50,0.95);
    border-color:#aaa;
  }
  .quest-log-badge {
    min-width:20px;
    padding:2px 6px;
    border-radius:4px;
    background:rgba(255,255,255,0.15);
    color:white;
    font-size:11px;
    text-align:center;
  }
  #questLogPanel {
    position:fixed;
    top:160px;
    left:10px;
    width:280px;
    max-height:calc(100vh - 280px);
    background:rgba(30,30,30,0.95);
    border:2px solid #888;
    border-radius:8px;
    padding:12px;
    color:white;
    font-family:monospace;
    display:none;
    overflow:hidden;
    z-index:1400;
  }
  .quest-log-header {
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    margin-bottom:10px;
    gap:10px;
  }
  .quest-log-heading {
    font-size:14px;
    font-weight:bold;
  }
  .quest-log-hint {
    font-size:11px;
    opacity:0.7;
  }
  .quest-log-count {
    font-size:11px;
    padding:3px 6px;
    border-radius:4px;
    background:rgba(255,255,255,0.15);
    color:white;
    white-space:nowrap;
  }
  .quest-log-list {
    max-height:calc(100vh - 340px);
    overflow-y:auto;
    padding-right:4px;
  }
  .quest-log-item {
    background:rgba(255,255,255,0.05);
    border:1px solid #555;
    padding:8px 10px;
    margin-bottom:8px;
    border-radius:6px;
    cursor:pointer;
    transition:background 0.2s ease, border-color 0.2s ease;
  }
  .quest-log-item:hover {
    background:rgba(255,255,255,0.1);
    border-color:#aaa;
  }
  .quest-log-title {
    font-size:13px;
    font-weight:bold;
    margin-bottom:4px;
  }
  .quest-log-summary {
    font-size:11px;
    opacity:0.85;
    margin-bottom:4px;
  }
  .quest-log-coords {
    font-size:10px;
    opacity:0.6;
  }
  .quest-log-empty {
    font-size:11px;
    opacity:0.7;
    padding:10px;
    border:1px dashed rgba(255,255,255,0.3);
    border-radius:6px;
  }

  #questDialog {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.6);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:2500;
  }
  .quest-dialog-card {
    width:420px;
    max-width:90vw;
    background:rgba(20,20,20,0.98);
    border:2px solid #888;
    border-radius:10px;
    padding:18px;
    color:white;
    font-family:monospace;
    box-shadow:0 20px 40px rgba(0,0,0,0.7);
  }
  .quest-dialog-header {
    display:flex;
    justify-content:space-between;
    gap:16px;
    align-items:flex-start;
    margin-bottom:12px;
  }
  .quest-dialog-title {
    font-size:18px;
    font-weight:700;
  }
  .quest-dialog-type {
    font-size:12px;
    opacity:0.75;
    letter-spacing:0.08em;
    text-transform:uppercase;
  }
  .quest-dialog-close {
    border:none;
    background:transparent;
    color:#f8fafc;
    font-size:20px;
    cursor:pointer;
    padding:0;
    line-height:1;
  }
  .quest-dialog-summary {
    font-size:13px;
    line-height:1.5;
    margin-bottom:16px;
    opacity:0.9;
  }
  .quest-dialog-section-title {
    font-size:12px;
    font-weight:bold;
    color:white;
    opacity:0.9;
    margin-bottom:6px;
  }
  #questDialogRewards {
    list-style:none;
    padding:0;
    margin:0 0 18px 0;
  }
  #questDialogRewards li {
    padding:6px 0;
    border-bottom:1px solid rgba(255,255,255,0.08);
    font-size:13px;
    display:flex;
    justify-content:space-between;
    gap:8px;
  }
  .quest-dialog-reward-name {
    font-weight:600;
  }
  .quest-dialog-reward-bonus {
    font-size:12px;
    opacity:0.7;
  }
  .quest-dialog-actions {
    display:flex;
    gap:12px;
  }
  .quest-dialog-btn {
    flex:1;
    height:36px;
    border-radius:6px;
    border:1px solid #777;
    font-weight:normal;
    cursor:pointer;
    font-family:monospace;
    transition:background 0.2s ease;
  }
  .quest-dialog-btn.primary {
    background:#444;
    color:white;
    border-color:#aaa;
  }
  .quest-dialog-btn.primary:hover {
    background:#555;
  }
  .quest-dialog-btn.secondary {
    background:rgba(255,255,255,0.08);
    color:white;
    border-color:#777;
  }
  .quest-dialog-btn.secondary:hover {
    background:rgba(255,255,255,0.12);
  }
  .quest-dialog-btn:disabled {
    opacity:0.4;
    cursor:not-allowed;
  }
  </style>
  </head>

  <body>
    <div id="loginScreen" style="position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:20000;">
      <div style="width:320px; background:rgba(20,20,20,0.9); border:2px solid #555; border-radius:10px; padding:18px; font-family:monospace; color:white; box-shadow:0 10px 30px rgba(0,0,0,0.6);">
        <div style="font-size:18px; font-weight:bold; margin-bottom:8px; text-align:center;">Enter Username</div>
        <div style="font-size:12px; opacity:0.8; margin-bottom:10px; text-align:center;">Reconnect with the same name to keep your progress.</div>
        <input id="loginName" style="width:100%; height:38px; border-radius:6px; border:1px solid #777; padding:0 10px; background:#111; color:white; font-family:monospace;" placeholder="Your name" maxlength="32" />
        <button id="loginBtn" style="margin-top:10px; width:100%; height:40px; border-radius:6px; border:1px solid #08f; background:linear-gradient(90deg,#0af,#08f); color:white; font-weight:bold; cursor:pointer;">Play</button>
        <div id="loginStatus" style="min-height:18px; margin-top:10px; font-size:12px; color:#ff8888; text-align:center;"></div>
      </div>
    </div>
  <canvas id="game"></canvas>
  <div id="billboards-container" style="position:fixed; top:0; left:0; pointer-events:none; z-index:100;"></div>
  <div id="hud"></div>

  <button id="questLogToggle">
    <span id="questLogToggleLabel">Quest Log</span>
    <span id="questLogToggleCount" class="quest-log-badge">0</span>
  </button>

  <div id="questLogPanel">
    <div class="quest-log-header">
      <div>
        <div class="quest-log-heading">Quest Log</div>
        <div class="quest-log-hint">NPCs with gold icons offer quests.</div>
      </div>
      <div id="questLogCount" class="quest-log-count">0 quests</div>
    </div>
    <div id="questLogList" class="quest-log-list"></div>
  </div>

  <div id="questDialog">
    <div class="quest-dialog-card">
      <div class="quest-dialog-header">
        <div>
          <div id="questDialogTitle" class="quest-dialog-title">Quest Giver</div>
          <div id="questDialogType" class="quest-dialog-type">Quest Details</div>
        </div>
        <button id="questDialogClose" class="quest-dialog-close" aria-label="Close quest dialog">×</button>
      </div>
      <div id="questDialogSummary" class="quest-dialog-summary"></div>
      <div>
        <div class="quest-dialog-section-title">Rewards</div>
        <ul id="questDialogRewards"></ul>
      </div>
      <div class="quest-dialog-actions">
        <button id="questDeclineBtn" class="quest-dialog-btn secondary">Decline</button>
        <button id="questAcceptBtn" class="quest-dialog-btn primary">Accept Quest</button>
      </div>
    </div>
  </div>

  <div id="panel">
    <div>Buidlings</div>
    <button id="buildBtn">Place Town Center</button>
    <button id="mineBtn">Place Mine</button>
    <button id="blacksmithBtn">Place Blacksmith</button>
  </div>

  <div id="buildingPanel" style="display:block; position:fixed; bottom:20px; left:20px; width:220px; height:120px; background:rgba(30,30,30,0.85); border:2px solid #888; padding:10px; color:white; font-family:monospace;">
    <div>Town Center Controls</div>
    <button id="createUnitBtn">Create Unit</button>
  </div>

  <div id="unit-panel" style="position:fixed; right:10px; top:10px; width:200px; background:rgba(0,0,0,0.7); color:white; padding:10px; border-radius:8px;">
      <h3>Selected Units</h3>
      <div id="unit-list"></div>
      <div id="unit-items" style="margin-top:10px;">
          <h4>Unit Items</h4>
          <ul id="items-list"></ul>
      </div>
  </div>

  <div id="editorPanel" style="
    position:fixed;
    right:10px;
    bottom:10px;
    left:auto;
    width:240px;
    background:rgba(0,0,0,0.75);
    color:white;
    padding:10px;
    border-radius:8px;
    font-family:monospace;
    z-index:1000;
  ">
    <button id="editorBtn" style="width:100%; height:36px;">Editor: OFF</button>
    <button id="collisionBtn" style="width:100%; height:32px; margin-top:8px;">Collision Debug: OFF</button>
    <div id="editorControls" style="margin-top:10px; display:none;">
    <div>Brush:</div>
    <select id="brushSelect" style="width:100%; height:30px;">
      <option value="" disabled selected>Loading tiles…</option>
    </select>
    <div style="margin-top:8px; display:flex; gap:6px; align-items:center;">
      <label for="zOrderInput" style="font-size:12px;">Z order</label>
      <input id="zOrderInput" type="number" value="0" step="1" style="flex:1; height:28px; background:#111; color:#fff; border:1px solid #555; padding:0 6px;" />
    </div>
    <div id="editorStats" style="margin-top:8px; font-size:12px; line-height:1.4; opacity:0.85;">
      <div>Tile: <span id="statTileSize">-</span></div>
      <div>Z: <span id="statZ">-</span></div>
      <div>Coll: <span id="statColl">-</span></div>
    </div>
    <div style="margin-top:10px; font-size:12px; opacity:0.9;">
      Left click: place<br/>
      Shift+Left click: delete<br/>
      c: toggle collision for object<br/>
      Scroll: collision size<br/>
      Shift+Scroll: tile size <br/>
      Ctrl+Click: select to change position<br/>
      Alt+Click (NPC/Spider selected): add/move waypoint | Shift+Alt+Click: remove waypoint<br/>
    </div>
    <button id="entityBtn" style="width:100%; height:36px; margin-top:8px;">
    Entity: OFF
  </button>
  </div>
  </div>
  <div id="entityPanel" style="
    display:none;
    position:fixed;
    left:20px;
    right:20px;
    top:20px;
    bottom:20px;
    width:320px;
    max-width:460px;
    max-height:calc(100vh - 40px);
    overflow:auto;
    background:rgba(0,0,0,0.9);
    color:white;
    padding:16px;
    border-radius:10px;
    border:2px solid #777;
    font-family:monospace;
    z-index:2000;
  ">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:bold;">Entity Inspector</div>
      <button id="entityCloseBtn" style="height:26px;">X</button>
    </div>

    <div style="margin-top:10px; font-size:12px; opacity:0.8;" id="entityIdLine"></div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Title</div>
      <input id="entityTitleInput" style="width:100%; height:30px;"/>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Biography</div>
      <textarea id="entityBioInput" style="width:100%; height:90px;"></textarea>
      <div style="margin-top:6px; font-size:11px; opacity:0.7; line-height:1.3;">
        Quest syntax: <code style="background:rgba(255,255,255,0.1); padding:2px 4px;">[Type: Kill](n=5, entity=spider)</code>
      </div>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Z-Order (render depth)</div>
      <input id="entityZOrderInput" type="number" style="width:100%; height:30px;" placeholder="0" />
    </div>

    <div style="margin-top:10px;">
      <label style="display:flex; align-items:center; gap:8px; font-size:12px; opacity:0.9; cursor:pointer;">
        <input id="entityQuestToggle" type="checkbox" style="cursor:pointer;" />
        <span>Gives Quest</span>
      </label>
    </div>

    <div style="margin-top:10px;">
      <div style="display:flex; gap:8px; align-items:center;">
        <div style="font-size:12px; opacity:0.8; flex:1;">Actions</div>
        <button id="entityAddActionBtn" style="height:26px;">+ Add</button>
      </div>
      <div id="entityActionsList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:6px;"></div>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Items</div>
      <ul id="entity-items-list" style="margin-top:6px; list-style:none; padding:0;"></ul>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Abilities</div>
      <div id="entity-abilities-list" style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;"></div>
    </div>

    <div style="margin-top:10px; display:flex; gap:8px;">
      <button id="entitySaveBtn" style="flex:1; height:34px;">Save</button>
      <button id="entityDeleteBtn" style="flex:1; height:34px;">Delete</button>
    </div>
  </div>




  <script>
  const canvas = document.getElementById("game");
  // Loading overlay + image loader instrumentation
  (function(){
    const overlay = document.createElement('div');
    overlay.id = 'loadingOverlay';
    overlay.style.position = 'fixed';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.right = '0';
    overlay.style.bottom = '0';
    overlay.style.background = '#000';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.zIndex = '99999';
    overlay.style.flexDirection = 'column';
    overlay.style.color = 'white';
    overlay.innerHTML = `
      <div style="font-family:monospace; font-size:18px; margin-bottom:12px;">Loading assets...</div>
      <div style="width:60%; max-width:520px; background:rgba(255,255,255,0.08); padding:6px; border-radius:6px;">
        <div id="loadingBarInner" style="height:18px; width:0%; background:linear-gradient(90deg,#4ee,#08f); border-radius:4px;"></div>
      </div>
      <div id="loadingPercent" style="font-family:monospace; margin-top:8px; opacity:0.9;">0%</div>
    `;
    document.body.appendChild(overlay);

    window.__loader = {
      total: 0,
      loaded: 0,
      errored: 0,
      _lastChange: Date.now(),
      _checkTimer: null,
      update() {
        const inner = document.getElementById('loadingBarInner');
        const pctEl = document.getElementById('loadingPercent');
        const total = Math.max(1, this.total);
        const done = Math.min(this.loaded + this.errored, total);
        const pct = Math.floor((done / total) * 100);
        if (inner) inner.style.width = pct + '%';
        if (pctEl) pctEl.textContent = pct + '%';

        // If everything loaded right now, wait a short quiescence period
        // to allow any late Image() constructions to register.
        if (done >= this.total) {
          const now = Date.now();
          const sinceChange = now - (this._lastChange || 0);
          const QUIESCE = 400; // ms
          clearTimeout(this._checkTimer);
          if (sinceChange >= QUIESCE) {
            window.ASSETS_LOADED = true;
            setTimeout(() => { overlay.style.display = 'none'; }, 120);
          } else {
            // schedule a recheck after the remaining quiesce interval
            this._checkTimer = setTimeout(() => this.update(), QUIESCE - sinceChange + 10);
          }
        }
      }
    };

    // Monkeypatch Image to auto-register loads
    const NativeImage = window.Image;
    function LoaderImage() {
      const img = new NativeImage();
      try { window.__loader.total++; window.__loader._lastChange = Date.now(); } catch(e){}
      img.addEventListener('load', function(){ try{ window.__loader.loaded++; window.__loader.update(); }catch(e){} });
      img.addEventListener('error', function(){ try{ window.__loader.errored++; window.__loader.update(); }catch(e){} });
      return img;
    }
    LoaderImage.prototype = NativeImage.prototype;
    window.Image = LoaderImage;
    // start as not loaded
    window.ASSETS_LOADED = false;
  })();
  let editorMode = false;
  let entityMode = false;
  let editorTileW = 256;
  let editorTileH = 256;
  let editorTileAspect = 1;
  let editorTileOverride = false;
  let editorCollisionEnabled = true;
  let editorCollisionW = 64;
  let editorCollisionH = 64;
  let editorCollisionOffsetX = 0;
  let editorCollisionOffsetY = 0;

  // Global variables
  let camera = {x:0,y:0};
  let groundItems = [];
  let trees = [];
  let resources = [];
  let buildings = [];
  let myUnits = [];
  let players = {};
  let resourceCounts = { red: 0, green: 0, blue: 0 };
  window.resourceCounts = resourceCounts;
  let hoveredResource = null;
  let hoveredGroundItem = null;
  let hoveredPlayerSid = null;
  let hoveredAttackEntity = null;
  let draggingPickup = null;
  let selectedUnits = [];
  let allUnits = {};
  let dragMouse = {x:0,y:0};
  let mouse = {x:0,y:0};
  let buildMode = false;
  let localBuildingPlaced = false;
    let mineMode = false;
    let blacksmithMode = false;
    let localBlacksmithPlaced = false;
  const socket = io({autoConnect: false});
  socket.on("server_debug", (data) => { try { console.log("SERVER_DEBUG:", data.msg); } catch(e){} });
  socket.on("smith_upgrade_result", (data) => {
    try { console.log("SMITH_RESULT", data); } catch(e){}
    if (!data) return;
    const msg = data.success
      ? `Blacksmith upgraded item to +${data.bonus || 0}`
      : (data.error || "Blacksmith upgrade failed");
    // Optional inline feedback could be added here (no popups by request)
    // Refresh inspector if this is the currently viewed entity
    if (data.entityId && selectedEntityId === data.entityId) {
      const updated = (mapObjects || []).find(x => x.id === data.entityId);
      if (updated) openEntityInspector(updated);
    }
  });
  // Building image and default size (needed by static/draw.js)
  const BUILD_W = 256;
  const BUILD_H = 256;
  const buildingImg = new Image();
  buildingImg.src = "static/tiles/building.png";
  // Mine image and default size (used by mine placement ghost)
  const MINE_W = 256;
  const MINE_H = 256;
  const mineImg = new Image();
  mineImg.src = "static/tiles/mine.png";
  const BLACKSMITH_W = 256;
  const BLACKSMITH_H = 256;
  const blacksmithImg = new Image();
  blacksmithImg.src = "static/tiles/blacksmith.png";
  // Client-side per-town-center population limit (used for HUD cap calculation)
  const POP_LIMIT = 10;
  // How many town centers a player may place
  const BUILD_LIMIT = 1;
  // Cost in resources to place a town center
  const TOWN_CENTER_COST = 5;

  // --- LOGIN UI ---
  const loginScreen = document.getElementById("loginScreen");
  const loginNameInput = document.getElementById("loginName");
  const loginBtn = document.getElementById("loginBtn");
  const loginStatus = document.getElementById("loginStatus");

  let mySid = null;
  let currentUsername = null;
  const savedName = localStorage.getItem("aoe_username");
  if (savedName && loginNameInput) loginNameInput.value = savedName;

  function beginLogin() {
    const name = (loginNameInput?.value || "").trim();
    if (!name) {
      if (loginStatus) loginStatus.textContent = "Enter a username";
      return;
    }
    currentUsername = name;
    if (loginStatus) loginStatus.textContent = "Connecting...";
    if (loginBtn) loginBtn.disabled = true;
    socket.auth = { username: name };
    if (socket.connected) {
      socket.emit("login", { username: name });
    } else {
      socket.connect();
    }
  }

  loginBtn?.addEventListener("click", beginLogin);
  loginNameInput?.addEventListener("keydown", (e) => {
    if (e.key === "Enter") beginLogin();
  });
  </script>

  <script src="static/input.js"></script>
  <script src="static/update.js"></script>
  <script src="static/draw.js"></script>
  <script src="static/billboard.js"></script>
  <script src="static/editor.js"></script>

  <script>
  // ===== QUEST PARSING =====
  function parseQuestFromBio(bio) {
    if (!bio || typeof bio !== 'string') return null;
    
    // Pattern: [Type: QuestType](param1=val1, param2=val2)
    const match = bio.match(/\[Type:\s*(\w+)\]\s*\(([^)]+)\)/);
    if (!match) return null;
    
    const questType = match[1];
    const paramsStr = match[2];
    
    // Parse params like "n=5, entity=spider"
    const params = {};
    const paramPairs = paramsStr.split(',');
    for (const pair of paramPairs) {
      const [key, value] = pair.trim().split('=').map(s => s.trim());
      if (key && value) {
        // Try to parse as number, otherwise keep as string
        params[key] = isNaN(value) ? value : parseInt(value, 10);
      }
    }
    
    return { type: questType, params };
  }
  
  /* ================= SETUP ================= */
  const ctx = canvas.getContext("2d");
  const hud = document.getElementById("hud");
  const panel = document.getElementById("panel");
  const buildBtn = document.getElementById("buildBtn");
  const mineBtn = document.getElementById("mineBtn");
  const blacksmithBtn = document.getElementById("blacksmithBtn");

  function updateBuildButton() {
    if (!buildBtn) return;
    const owned = (mapObjects || []).filter(o => o.kind === 'town_center' && o.owner === mySid).length;
    buildBtn.innerText = `Place Town Center (Cost: ${TOWN_CENTER_COST} red) (${owned}/${BUILD_LIMIT})`;
    // disable if reached build limit or not enough red resources
    buildBtn.disabled = (owned >= BUILD_LIMIT) || ((resourceCounts.red || 0) < TOWN_CENTER_COST);
    buildBtn.title = `Cost: ${TOWN_CENTER_COST} resources`;
  }

  function updateMineButton() {
    if (!mineBtn) return;
    const mineCost = 3;
    mineBtn.innerText = `Place Mine (Cost: ${mineCost} blue)`;
    mineBtn.disabled = ((resourceCounts.blue || 0) < mineCost);
    mineBtn.title = `Cost: ${mineCost} blue resources`;
  }

  function updateBlacksmithButton() {
    if (!blacksmithBtn) return;
    const smithCost = 3;
    blacksmithBtn.innerText = `Place Blacksmith (Cost: ${smithCost} red)`;
    blacksmithBtn.disabled = ((resourceCounts.red || 0) < smithCost);
    blacksmithBtn.title = `Cost: ${smithCost} red resources`;
  }

  // Entity inspector elements (used by openEntityInspector / input handlers)
  const entityPanelEl = document.getElementById("entityPanel");
  const entityIdLine = document.getElementById("entityIdLine");
  const entityTitleInput = document.getElementById("entityTitleInput");
  const entityBioInput = document.getElementById("entityBioInput");
  const entityAddActionBtn = document.getElementById("entityAddActionBtn");
  const entityActionsList = document.getElementById("entityActionsList");
  const entitySaveBtn = document.getElementById("entitySaveBtn");
  const entityDeleteBtn = document.getElementById("entityDeleteBtn");
  const entityCloseBtn = document.getElementById("entityCloseBtn");

  let selectedEntityId = null;
  draggingPickup = null;

  if (entityCloseBtn) {
    entityCloseBtn.onclick = () => {
      if (entityPanelEl) entityPanelEl.style.display = "none";
      selectedEntityId = null;
      try { if (window.__mineCountdownTimer) { clearInterval(window.__mineCountdownTimer); window.__mineCountdownTimer = null; } } catch(e){}
      try { if (window.__smithCountdownTimer) { clearInterval(window.__smithCountdownTimer); window.__smithCountdownTimer = null; } } catch(e){}
    };
  }

  socket.on("connect", () => {
    if (currentUsername) {
      if (loginStatus) loginStatus.textContent = "Logging in...";
      socket.emit("login", { username: currentUsername });
    }
  });

  socket.on("login_success", ({ playerId }) => {
    mySid = playerId;
    currentUsername = playerId;
    localStorage.setItem("aoe_username", playerId);
    if (loginStatus) loginStatus.textContent = "";
    if (loginScreen) loginScreen.style.display = "none";
    if (loginBtn) loginBtn.disabled = false;
    // ✅ request initial map and state once authenticated
    socket.emit("request_state");
    socket.emit("request_map");
  });

  socket.on("login_error", (payload) => {
    mySid = null;
    if (loginStatus) loginStatus.textContent = (payload && payload.msg) || "Login failed";
    if (loginBtn) loginBtn.disabled = false;
  });

  socket.on("login_required", () => {
    mySid = null;
    if (loginScreen) loginScreen.style.display = "flex";
    // if we already have a username and are connected, retry login
    if (currentUsername && socket.connected) {
      if (loginStatus) loginStatus.textContent = "Logging in...";
      socket.emit("login", { username: currentUsername });
    }
  });

  socket.on("disconnect", () => {
    mySid = null;
    if (loginScreen) loginScreen.style.display = "flex";
    if (loginBtn) loginBtn.disabled = false;
    if (loginStatus) loginStatus.textContent = "Disconnected";
  });

  socket.on("connect_error", (err) => {
    if (loginStatus) loginStatus.textContent = err?.message || "Connection error";
    if (loginBtn) loginBtn.disabled = false;
  });


  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  let DEBUG_COLLISIONS = false; // toggle on/off


  function setEntityInspectorEditable(canEdit) {
    entityTitleInput.disabled = !canEdit;
    entityBioInput.disabled = !canEdit;

    entityAddActionBtn.disabled = !canEdit;
    entitySaveBtn.disabled = !canEdit;
    entityDeleteBtn.disabled = !canEdit;

    // Optional visual cue
    entityTitleInput.style.opacity = canEdit ? "1" : "0.7";
    entityBioInput.style.opacity   = canEdit ? "1" : "0.7";
  }

  // Track when user is actively editing entity fields
  entityTitleInput.addEventListener("focus", () => { isEditingEntity = true; });
  entityTitleInput.addEventListener("blur", () => { isEditingEntity = false; });
  entityBioInput.addEventListener("focus", () => { isEditingEntity = true; });
  entityBioInput.addEventListener("blur", () => { isEditingEntity = false; });
  
  const entityZOrderInput = document.getElementById("entityZOrderInput");
  if (entityZOrderInput) {
    entityZOrderInput.addEventListener("focus", () => { isEditingEntity = true; });
    entityZOrderInput.addEventListener("blur", () => { isEditingEntity = false; });
  }
  
  const entityQuestToggle = document.getElementById("entityQuestToggle");
  if (entityQuestToggle) {
    const beginQuestEdit = () => { isEditingEntity = true; };
    const endQuestEdit = () => { isEditingEntity = false; };

    entityQuestToggle.addEventListener("focus", beginQuestEdit);
    entityQuestToggle.addEventListener("blur", endQuestEdit);

    entityQuestToggle.addEventListener("change", () => {
      isEditingEntity = true;

      if (!selectedEntityId) return;
      const target = mapObjects.find(x => x.id === selectedEntityId);
      if (!target) return;
      ensureEntityMeta(target);
      target.meta.givesQuest = !!entityQuestToggle.checked;
    });
  }


  /* ================= PLAYER SPRITES ================= */

  const SPRITE_W = 256;
  const SPRITE_H = 256;
  const DIRECTIONS = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337];
  const IDLE_FRAMES = 24;
  const WALK_FRAMES = 24;
  const NPC_WALK_FRAMES = 16;
  const SPIDER_WALK_FRAMES = 9;
  const ANIM_SPEED = 0.3;


  const UNIT_RADIUS = 18;
  const PLAYER_RADIUS = 20;
  const TREE_RADIUS = 140;
  const RESOURCE_RADIUS_COLLIDE = 15;

  // Buildings use rectangle collision
  const BUILD_COLLISION_PADDING = -50;


  const UNIT_ATTACK_RANGE = PLAYER_RADIUS + UNIT_RADIUS + 10; // 10 extra for buffer
  const UNIT_ATTACK_DPS = 30; // damage per second
  const ATTACK_COOLDOWN = 1000 / 60; // 1 tick per frame (60fps)
  const UNIT_MAX_HEALTH = 100;
  const ATTACK_ANIM_FRAMES = 24;


  // groundItems declared earlier in the global setup

  const itemIcons = {
    sword: new Image(),
    shield: new Image()
  };
  itemIcons.sword.src = "static/items/sword.png";   // make these files
  itemIcons.shield.src = "static/items/shield.png"; // or draw text fallback
  const GROUND_ITEM_SIZE = 32;
  const PICKUP_RADIUS = 26;

  function itemStatText(item) {
    const n = (typeof item === "string" ? item : (item && item.name) || "").toLowerCase();
    const bonusRaw = (item && typeof item === "object") ? Number(item.bonus || 0) : 0;
    const bonus = Math.max(0, isNaN(bonusRaw) ? 0 : bonusRaw);
    if (n === "sword") {
      const atk = 1 + bonus;
      return `+${atk} Attack (+${atk * 5} DPS)`;
    }
    if (n === "shield") {
      const def = 1 + bonus;
      return `+${def} Defense (+${def * 15} HP)`;
    }
    return "";
  }

  const PICKUP_DISTANCE = 120; // how close unit must be to pick up from ground
  let currentItemsUnitId = null; // which unit's equipment UI is currently showing


  function unitCanPickup(unit, groundItem) {
    return Math.hypot(unit.x - groundItem.x, unit.y - groundItem.y) <= PICKUP_DISTANCE;
  }

  
  // `draggingPickup` and `dragMouse` are declared in the main globals block; do not re-declare here.


  function getFirstSelectedUnit() {
    return myUnits.find(u => u.selected) || null;
  }
  function onGlobalDragMove(e) {
    // keep mouse updated even over UI
    dragMouse.x = e.clientX;
    dragMouse.y = e.clientY;

    // optional: block text selection while dragging
    e.preventDefault();
  }

  // onGlobalDragEnd moved to static/input.js

  function renderUnitItems(unit) {
    currentItemsUnitId = unit.id;

    const itemsList = document.getElementById("items-list");
    itemsList.innerHTML = "";

    if (!unit.itemSlots) unit.itemSlots = [null, null, null, null, null];

    for (let i = 0; i < 5; i++) {
      const slot = unit.itemSlots[i];

      const li = document.createElement("li");
      li.style.display = "flex";
      li.style.alignItems = "center";
      li.style.justifyContent = "space-between";
      li.style.border = "1px solid #777";
      li.style.borderRadius = "6px";
      li.style.padding = "6px";
      li.style.marginBottom = "6px";
      li.style.background = "rgba(255,255,255,0.05)";

      li.dataset.slotIndex = String(i);
      li.dataset.unitId = unit.id;

      const left = document.createElement("div");
      const statText = slot ? itemStatText(slot) : "";
      const hoverText = slot
        ? `${slot.name || "item"}${statText ? " — " + statText : ""}`
        : "Empty slot";
      left.textContent = `Slot ${i + 1}: ${slot ? slot.name : "(empty)"}${slot && typeof slot.bonus !== "undefined" ? ` (+${Math.max(0, Number(slot.bonus) || 0)})` : ""}`;
      li.title = hoverText;
      li.appendChild(left);

      // Allow dropping from ground -> slot OR slot -> slot
      li.addEventListener("dragover", (e) => {
        e.preventDefault();
        li.style.outline = "2px dashed #fff";
      });
      li.addEventListener("dragleave", () => {
        li.style.outline = "";
      });

      li.addEventListener("drop", (e) => {
        e.preventDefault();
        li.style.outline = "";

        const payloadStr = e.dataTransfer.getData("application/json");
        if (!payloadStr) return;

        let payload;
        try { payload = JSON.parse(payloadStr); } catch { return; }

        const targetUnit = myUnits.find(u => u.id === unit.id);
        if (!targetUnit) return;
        if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null, null, null, null];

        const slotIndex = i;

    if (payload.type === "ground_item") {
      socket.emit("pickup_item", {
        unitId: unit.id,
        slotIndex: i,
        groundItemId: payload.groundItemId
      });
      // Optimistic local update: remove ground item and add to unit slot
      try {
        const giIndexLocal = groundItems.findIndex(g => g.id === payload.groundItemId);
        if (giIndexLocal !== -1) groundItems.splice(giIndexLocal, 1);
        unit.itemSlots = unit.itemSlots || [];
        unit.itemSlots[i] = { id: ("local-" + (payload.groundItemId || Math.random())), name: (payload.name || "item") };
        if (currentItemsUnitId === unit.id) renderUnitItems(unit);
      } catch (ex) { console.error("optimistic pickup_item failed", ex); }
      return;
    }

        // If dropping an entity item onto a unit slot
        if (payload.type === "entity_item") {
          // payload: { type: 'entity_item', entityId, slotIndex, item }
          socket.emit("entity_give_to_unit", {
            entityId: payload.entityId,
            entitySlotIndex: payload.slotIndex,
            unitId: unit.id,
            slotIndex: i
          });
          return;
        }

        // If dropping a unit item (slot -> slot) (optional nice feature):
        if (payload.type === "unit_item") {
          const fromUnit = myUnits.find(u => u.id === payload.unitId);
          if (!fromUnit || !fromUnit.itemSlots) return;

          const fromSlot = payload.slotIndex;
          const moving = fromUnit.itemSlots[fromSlot];
          if (!moving) return;

          // If target slot occupied, swap
          const temp = targetUnit.itemSlots[slotIndex];
          targetUnit.itemSlots[slotIndex] = moving;
          fromUnit.itemSlots[fromSlot] = temp || null;

          renderUnitItems(targetUnit);
          return;
        }
      });

      // If slot has item: make it draggable out
      if (slot) {
        const chip = document.createElement("div");
        chip.textContent = "drag";
        chip.title = hoverText;
        chip.style.padding = "3px 8px";
        chip.style.border = "1px solid #aaa";
        chip.style.borderRadius = "6px";
        chip.style.cursor = "grab";
        chip.style.userSelect = "none";
        chip.style.background = "rgba(0,0,0,0.3)";
        chip.draggable = true;

        chip.addEventListener("dragstart", (e) => {
          const payload = {
            type: "unit_item",
            unitId: unit.id,
            slotIndex: i,
            item: slot
          };
          e.dataTransfer.setData("application/json", JSON.stringify(payload));
          e.dataTransfer.effectAllowed = "move";
        });

        li.appendChild(chip);
      }

      itemsList.appendChild(li);
    }
  }




  canvas.addEventListener("dragover", (e) => {
    e.preventDefault(); // allow drop
  });

  canvas.addEventListener("drop", (e) => {
    e.preventDefault();

    const payloadStr = e.dataTransfer.getData("application/json");
    if (!payloadStr) return;

    let payload;
    try { payload = JSON.parse(payloadStr); } catch { return; }

    // Convert screen -> world
    const wx = camera.x + e.clientX - canvas.width / 2;
    const wy = camera.y + e.clientY - canvas.height / 2;

    // Dropping equipment item onto world => SERVER creates ground item
    if (payload.type === "unit_item") {
      socket.emit("drop_item", {
        unitId: payload.unitId,
        slotIndex: payload.slotIndex,
        x: wx,
        y: wy
      });
      return;
    }
    // Dropping an item from an entity onto the world -> create ground item
    if (payload.type === "entity_item") {
      console.log('canvas drop: entity_item', { payload, socketConnected: socket && socket.connected, wx, wy });
      // optimistic: remove from entity UI and add local ground item for immediate feedback
      try {
        const ent = (mapObjects || []).find(m => m.id === payload.entityId);
        let itemName = null;
        if (ent && ent.itemSlots && ent.itemSlots[payload.slotIndex]) {
          const it = ent.itemSlots[payload.slotIndex];
          itemName = it && it.name;
          ent.itemSlots[payload.slotIndex] = null;
          if (selectedEntityId === ent.id) openEntityInspector(ent);
        }
        const localGi = { id: 'local-' + (Date.now() + Math.floor(Math.random()*1000)), name: itemName || 'item', x: wx, y: wy };
        groundItems = groundItems || [];
        groundItems.push(localGi);
      } catch (ex) { console.error('optimistic entity->ground failed', ex); }

      socket.emit("entity_give_to_ground", {
        entityId: payload.entityId,
        entitySlotIndex: payload.slotIndex,
        x: wx,
        y: wy
      });

      return;
    }
  });




  function ensureEntityMeta(o) {
    if (!o.meta) o.meta = {};
    if (!o.meta.entity) o.meta.entity = true;
    if (typeof o.meta.title !== "string") o.meta.title = "";
    if (typeof o.meta.bio !== "string") o.meta.bio = "";
    if (!Array.isArray(o.meta.actions)) o.meta.actions = [];
  }

  function getDefaultEntityTitle(o) {
    if (o.type === "building") return "Building";
    if (o.type === "tile") return o.kind ? prettyName(o.kind) : "Tile";
    return "Entity";
  }

  function openEntityInspector(o) {
    ensureEntityMeta(o);
    selectedEntityId = o.id;

    const ownerLabel = o.owner ? (players[o.owner]?.color ? o.owner.slice(0,6) : o.owner.slice(0,6)) : "(none)";
    
    // Build info line with size and collision info for tiles
    let infoLine = `id: ${o.id} | type: ${o.type}${o.kind ? " | kind: " + o.kind : ""} | owner: ${ownerLabel}`;
    
    if (o.type === "tile" && o.meta) {
      const tileW = o.meta.w || 0;
      const tileH = o.meta.h || 0;
      const collisionW = o.meta.cw || 0;
      const collisionH = o.meta.ch || 0;
      const collisionEnabled = o.meta.collides || false;
      
      infoLine += ` | size: ${tileW}x${tileH}`;
      if (collisionEnabled) {
        infoLine += ` | collision: ${collisionW}x${collisionH}`;
      } else {
        infoLine += ` | collision: OFF`;
      }
    }
    
    entityIdLine.textContent = infoLine;

    entityTitleInput.value = o.meta.title || getDefaultEntityTitle(o);
    entityBioInput.value = o.meta.bio || "";
    
    // Set quest toggle
    const questToggle = document.getElementById("entityQuestToggle");
    if (questToggle) {
      questToggle.checked = !!o.meta.givesQuest;
    }

    renderEntityActions(o);

    // ✅ Only allow editing TILE title/bio when editor mode is ON
    const isTile = (o.type === "tile");
    const canEdit = !(isTile && !editorMode);
    setEntityInspectorEditable(canEdit);

    // Optional: make it obvious why it's locked
    if (!canEdit) {
      entityIdLine.textContent += "  |  (read-only: enable Editor to edit tile text)";
    }

    // Render entity item slots
    const entityItemsEl = document.getElementById("entity-items-list");
    if (entityItemsEl) {
      entityItemsEl.innerHTML = "";
      // If in editor mode, show controls to add/remove persistent item slots
      if (editorMode) {
        const ctrl = document.createElement("div");
        ctrl.style.display = "flex";
        ctrl.style.gap = "6px";
        ctrl.style.marginBottom = "6px";

        const inc = document.createElement("button");
        inc.textContent = "+ Slot";
        inc.style.height = "26px";
        inc.onclick = () => {
          o.itemSlots = o.itemSlots || [];
          o.itemSlots.push(null);
          socket.emit("update_map_object", { id: o.id, itemSlots: o.itemSlots });
          // re-open inspector to reflect change
          openEntityInspector(o);
        };

        const dec = document.createElement("button");
        dec.textContent = "- Slot";
        dec.style.height = "26px";
        dec.onclick = () => {
          o.itemSlots = o.itemSlots || [];
          if (o.itemSlots.length === 0) return;
          // prevent removing a non-empty slot
          const last = o.itemSlots[o.itemSlots.length - 1];
          if (last) { alert("Cannot remove slot: last slot is not empty."); return; }
          o.itemSlots.pop();
          socket.emit("update_map_object", { id: o.id, itemSlots: o.itemSlots });
          openEntityInspector(o);
        };

        ctrl.appendChild(inc);
        ctrl.appendChild(dec);
        entityItemsEl.appendChild(ctrl);
      }
      const slots = o.itemSlots || [];
      const slotCount = Math.max(2, slots.length);

      // container that will wrap slot elements (prevents vertical stacking)
      const slotsContainer = document.createElement("div");
      slotsContainer.style.display = "flex";
      slotsContainer.style.flexWrap = "wrap";
      slotsContainer.style.gap = "6px";
      slotsContainer.style.alignItems = "flex-start";

      const compact = slotCount > 3;

      for (let si = 0; si < slotCount; si++) {
        const s = slots[si] || null;
        const li = document.createElement("li");
        li.dataset.slotIndex = si;
        li.dataset.entityId = o.id;

        if (compact) {
          // small square slot
          li.style.width = "40px";
          li.style.height = "40px";
          li.style.display = "inline-flex";
          li.style.alignItems = "center";
          li.style.justifyContent = "center";
          li.style.border = "1px solid #666";
          li.style.borderRadius = "4px";
          li.style.background = s ? "rgba(255,255,255,0.06)" : "transparent";
          const statTxt = s ? itemStatText(s) : "";
          li.title = s ? ((s.name || "item") + (statTxt ? " — " + statTxt : "")) : `(empty)`;
          const dot = document.createElement("div");
          dot.style.width = "22px";
          dot.style.height = "22px";
          dot.style.borderRadius = "3px";
          dot.style.background = s ? "rgba(200,200,200,0.9)" : "rgba(0,0,0,0.15)";
          dot.style.display = "flex";
          dot.style.alignItems = "center";
          dot.style.justifyContent = "center";
          dot.style.fontSize = "11px";
          dot.style.color = "#000";
          dot.textContent = s ? (s.name ? s.name[0].toUpperCase() : "I") : "";
          dot.title = s ? (statTxt || "") : "";
          li.appendChild(dot);
          li._dot = dot;
        } else {
          li.style.display = "flex";
          li.style.justifyContent = "space-between";
          li.style.alignItems = "center";
          li.style.border = "1px solid #666";
          li.style.padding = "6px";
          li.style.marginBottom = "6px";
          const left = document.createElement("div");
          const statSuffix = s ? itemStatText(s) : "";
          const bonusLabel = s && typeof s.bonus !== "undefined" ? ` (+${Math.max(0, Number(s.bonus) || 0)})` : "";
          left.textContent = `Slot ${si+1}: ${s ? s.name : "(empty)"}${bonusLabel}${statSuffix ? " (" + statSuffix + ")" : ""}`;
          li.appendChild(left);
        }

        // allow dropping unit_item onto entity slot
        li.addEventListener("dragover", (e) => { e.preventDefault(); li.style.outline = "2px dashed #fff"; });
        li.addEventListener("dragleave", () => { li.style.outline = ""; });
        li.addEventListener("drop", (e) => {
          e.preventDefault(); li.style.outline = "";
          const payloadStr = e.dataTransfer.getData("application/json");
          if (!payloadStr) return;
          let payload; try { payload = JSON.parse(payloadStr); } catch { return; }
          // dropping a unit item onto entity
          console.log("entity-slot drop", { entityId: o.id, slotIndex: si, payload });
          if (payload.type === "unit_item") {
            socket.emit("unit_give_to_entity", {
              unitId: payload.unitId,
              unitSlotIndex: payload.slotIndex,
              entityId: o.id,
              entitySlotIndex: si
            });
          }
        });

        // if slot has item, make draggable
        if (s) {
          const chip = document.createElement("div");
          chip.textContent = s.name || "item";
          chip.title = itemStatText(s) || "";
          chip.style.padding = "3px 8px";
          chip.style.border = "1px solid #aaa";
          chip.style.borderRadius = "6px";
          chip.style.cursor = "grab";
          chip.draggable = true;
          chip.addEventListener("dragstart", (e) => {
            const payload = { type: "entity_item", entityId: o.id, slotIndex: si, item: s };
            e.dataTransfer.setData("application/json", JSON.stringify(payload));
            e.dataTransfer.effectAllowed = "move";
          });
          li.appendChild(chip);
        }

        slotsContainer.appendChild(li);
      }
      // append the wrapped slots container once
      entityItemsEl.appendChild(slotsContainer);
    }

      // Render Abilities
      const abilitiesEl = document.getElementById("entity-abilities-list");
      if (abilitiesEl) {
        abilitiesEl.innerHTML = "";
        // Only town_center entities have spawn ability
        const isTownCenter = (o.kind === "town_center" || (o.meta && o.meta.kind === "town_center"));
        if (isTownCenter) {
          const btn = document.createElement("button");
          btn.textContent = "Spawn Unit (cost: 1 green)";
          btn.style.height = "30px";
          // disable for players who don't own this town center or lack green resources
          const owned = (o.owner && o.owner === mySid);
          const hasGreen = (window.resourceCounts && (window.resourceCounts.green || 0) >= 1);
          btn.disabled = !owned || !hasGreen;
          if (!owned) {
            btn.title = "You do not own this building";
            btn.style.opacity = "0.5";
          } else if (!hasGreen) {
            btn.title = "Requires 1 green resource to spawn";
            btn.style.opacity = "0.5";
          }
          btn.onclick = () => {
            if (!o || !o.id) return;
            if (!owned) return; // double-check on click
            socket.emit("spawn_unit_from_entity", { entityId: o.id });
          };
          abilitiesEl.appendChild(btn);
        }

        // Mine production ability: dropdown + 30s timer
        const isMine = (o.kind === "mine");
        if (isMine) {
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.gap = "8px";
          wrap.style.alignItems = "center";

          const owned = !!o.owner && o.owner === mySid;

          const label = document.createElement("div");
          label.textContent = "Mine:";
          wrap.appendChild(label);

          const select = document.createElement("select");
          ["red","green","blue"].forEach(t => {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t.charAt(0).toUpperCase() + t.slice(1);
            select.appendChild(opt);
          });
          const current = (o.meta && o.meta.mine && o.meta.mine.resource) ? o.meta.mine.resource : "red";
          select.value = current;
          if (!owned) {
            select.disabled = true;
            select.title = "Only the owner can change the resource";
          }
          select.onchange = () => {
            if (!owned) return;
            const sel = select.value;
            // Preserve all existing meta when updating just the resource type
            const updated = mapObjects.find(x => x.id === o.id);
            if (updated && updated.meta && updated.meta.mine) {
              updated.meta.mine.resource = sel;
              socket.emit("update_map_object", { id: o.id, meta: updated.meta });
            } else {
              // Fallback if meta not found
              socket.emit("update_map_object", { id: o.id, meta: { mine: { resource: sel } } });
            }
          };
          wrap.appendChild(select);

          const timerEl = document.createElement("div");
          wrap.appendChild(timerEl);

          // Function to update timer display
          const updateMineTimer = () => {
            // Re-fetch from mapObjects to ensure fresh nextTick
            const current = mapObjects.find(x => x.id === selectedEntityId);
            if (!current || current.kind !== "mine") {
              // Entity deleted or no longer a mine, stop timer
              if (window.__mineCountdownTimer) {
                clearInterval(window.__mineCountdownTimer);
                window.__mineCountdownTimer = null;
              }
              return;
            }
            const nextTick = (current.meta && current.meta.nextTick) ? Number(current.meta.nextTick) : null;
            const now = Date.now() / 1000;
            let rem = (nextTick) ? Math.max(0, Math.ceil(nextTick - now)) : 30;
            timerEl.textContent = `Next in ${rem}s`;
            
            // Debug logs
            if (!window.__mineTimerDebugLog) {
              window.__mineTimerDebugLog = { count: 0 };
            }
            window.__mineTimerDebugLog.count++;
            if (window.__mineTimerDebugLog.count % 5 === 0) {
              console.log(`[MINE_TIMER] ${window.__mineTimerDebugLog.count}: nextTick=${nextTick}, now=${now.toFixed(1)}, rem=${rem}s, resource=${current.meta?.mine?.resource}`);
            }
          };

          // Update immediately, then every 1s
          updateMineTimer();

          // live countdown based on server-provided nextTick
          // Read from mapObjects to get fresh data on each tick, not stale closure
          try { if (window.__mineCountdownTimer) clearInterval(window.__mineCountdownTimer); } catch(e){}
          window.__mineCountdownTimer = setInterval(updateMineTimer, 1000);

          abilitiesEl.appendChild(wrap);
        }

        // Blacksmith ability: upgrade the slotted item for 3 blue
        const isBlacksmith = (o.kind === "blacksmith");
        if (isBlacksmith) {
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.flexDirection = "column";
          wrap.style.gap = "6px";

          const owned = !!o.owner && o.owner === mySid;
          const smithSlots = o.itemSlots || [];
          const smithItem = smithSlots[0] || null;
          const bonusVal = smithItem ? Math.max(0, Number(smithItem.bonus) || 0) : 0;

          const label = document.createElement("div");
          label.textContent = smithItem
            ? `Slot 1: ${smithItem.name || "item"} (bonus +${bonusVal})`
            : "Slot 1: (empty)";
          label.title = smithItem ? itemStatText(smithItem) : "Drag an item into the Blacksmith's slot";
          wrap.appendChild(label);

          const hint = document.createElement("div");
          hint.style.fontSize = "12px";
          hint.style.opacity = "0.8";
          hint.textContent = "Use the Items section above to drop an item into this Blacksmith.";
          wrap.appendChild(hint);

          const btn = document.createElement("button");
          btn.textContent = "Upgrade item (cost: 3 blue)";
          btn.style.height = "30px";
          const hasBlue = (resourceCounts.blue || 0) >= 3;
          const hasItem = !!smithItem;
          btn.disabled = !owned || !hasItem || !hasBlue;
          if (!owned) {
            btn.title = "You do not own this building";
            btn.style.opacity = "0.6";
          } else if (!hasItem) {
            btn.title = "Place an item into the Blacksmith slot first";
            btn.style.opacity = "0.8";
          } else if (!hasBlue) {
            btn.title = "Requires 3 blue resources";
            btn.style.opacity = "0.8";
          }
          btn.onclick = () => {
            if (!owned || !hasItem || !hasBlue) return;
            socket.emit("smith_upgrade_item", { entityId: o.id, slotIndex: 0 });
          };
          wrap.appendChild(btn);

          abilitiesEl.appendChild(wrap);
        }
      }

      entityPanelEl.style.display = "block";
  }

  function renderEntityActions(o) {
    entityActionsList.innerHTML = "";
    ensureEntityMeta(o);

    for (let i = 0; i < o.meta.actions.length; i++) {
      const a = o.meta.actions[i];

      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.gap = "4px";
      wrap.style.alignItems = "center";

      const btn = document.createElement("button");
      btn.textContent = a.label || `Action ${i+1}`;
      btn.style.height = "26px";

      // Clicking action in inspector triggers an event (so you can hook gameplay)
      btn.onclick = () => {
        socket.emit("entity_action", { entityId: o.id, actionId: a.id, label: a.label });
        // optional local feedback:
        // console.log("entity_action", o.id, a);
      };

      const del = document.createElement("button");
      del.textContent = "✕";
      del.style.height = "26px";
      del.onclick = () => {
        o.meta.actions.splice(i, 1);
        renderEntityActions(o);
      };

      wrap.appendChild(btn);
      wrap.appendChild(del);
      entityActionsList.appendChild(wrap);
    }
  }
  entityAddActionBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    // If tile + editor off => no edits
    if (o.type === "tile" && !editorMode) return;

    ensureEntityMeta(o);

    const label = prompt("Action label?", "Inspect");
    if (!label) return;

    o.meta.actions.push({ id: crypto.randomUUID(), label });
    renderEntityActions(o);
  };


  entitySaveBtn.onclick = () => {
    if (!selectedEntityId) {
      console.log("entitySaveBtn: no selectedEntityId");
      return;
    }
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) {
      console.log("entitySaveBtn: entity not found in mapObjects", selectedEntityId);
      return;
    }

    // Allow billboard editing without editor mode
    if (o.type === "tile" && o.kind !== 'billboard' && !editorMode) {
      console.log("entitySaveBtn: cannot edit tile without editor mode", o.kind);
      return;
    }

    ensureEntityMeta(o);
    o.meta.title = entityTitleInput.value || "";
    o.meta.bio = entityBioInput.value || "";
    
    // Save z-order
    const zOrderInput = document.getElementById("entityZOrderInput");
    if (zOrderInput && zOrderInput.value !== "") {
      o.meta.z = parseFloat(zOrderInput.value) || 0;
    }
    
    // Save quest toggle
    const questToggle = document.getElementById("entityQuestToggle");
    if (questToggle) {
      o.meta.givesQuest = !!questToggle.checked;
    }
    
    const updatePayload = { id: o.id, meta: o.meta };
    console.log("entitySaveBtn: full meta.givesQuest =", updatePayload.meta.givesQuest);
    
    if (!socket || !socket.connected) {
      console.error("entitySaveBtn: socket not connected!");
      alert("Error: Socket not connected. Changes not saved.");
      return;
    }
    
    socket.emit("update_map_object", updatePayload);
    console.log("entitySaveBtn: update emitted successfully");
    
    // Clear the editing flag so server updates can refresh the inspector
    isEditingEntity = false;
    entityPanelEl.style.display = "none";
  };

  entityDeleteBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    // Allow billboard deletion without editor mode
    if (o.type === "tile" && o.kind !== 'billboard' && !editorMode) return;

    socket.emit("delete_map_object", { id: selectedEntityId });
    entityPanelEl.style.display = "none";
    selectedEntityId = null;
  };




  const playerSprites = {
    idle: {},
    walk: {},
    idleshadow:{},
    walkshadow:{},
  };

  const npcSprites = {
    idle: {},
    walk: {},
    idleshadow:{},
    walkshadow:{},
  };

  const spiderSprites = {
    walk: {},
  };

  function pad(num, length=3) { return num.toString().padStart(length, "0"); }
  function padFrame(num, length=4) { return num.toString().padStart(length, "0"); }



  for (const deg of DIRECTIONS) {
    const d = pad(deg);

    playerSprites.idle[d] = [];
    playerSprites.walk[d] = [];
    playerSprites.idleshadow[d] = [];
    playerSprites.walkshadow[d] = [];

    npcSprites.idle[d] = [];
    npcSprites.walk[d] = [];
    npcSprites.idleshadow[d] = [];
    npcSprites.walkshadow[d] = [];

    // Idle frames (same for both)
    for (let i = 1; i <= IDLE_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Idle/Body/${d}/Idle_Body_${d}_${padFrame(i)}.png`;
      playerSprites.idle[d].push(img);
      npcSprites.idle[d].push(img); // Share idle sprites
      const imgshadow = new Image();
      imgshadow.src = `static/Idle/Shadow/${d}/Idle_Shadow_${d}_${padFrame(i)}.png`;
      playerSprites.idleshadow[d].push(imgshadow);
      npcSprites.idleshadow[d].push(imgshadow);
    }

    // Player walk frames (Run folder)
    for (let i = 1; i <= WALK_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Run/Body/${d}/Run_Body_${d}_${padFrame(i)}.png`;
      playerSprites.walk[d].push(img);
      const imgshadow = new Image();
      imgshadow.src = `static/Run/Shadow/${d}/Run_Shadow_${d}_${padFrame(i)}.png`;
      playerSprites.walkshadow[d].push(imgshadow);
    }

    // NPC walk frames (Walk folder - 16 frames)
    for (let i = 1; i <= NPC_WALK_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Walk/Body/${d}/Walk_Body_${d}_${padFrame(i)}.png`;
      npcSprites.walk[d].push(img);
      const imgshadow = new Image();
      imgshadow.src = `static/Walk/Shadow/${d}/Walk_Shadow_${d}_${padFrame(i)}.png`;
      npcSprites.walkshadow[d].push(imgshadow);
    }

    // Spider walk frames (spiderframes/walk_forward/body folder - 16 frames, 1-indexed)
    spiderSprites.walk[d] = [];
    for (let i = 1; i <= SPIDER_WALK_FRAMES; i++) {
      const img = new Image();
      img.src = `static/spiderframes/walk_forward/body/${d}/Walk_Forward_Body_${d}_${padFrame(i)}.png`;
      spiderSprites.walk[d].push(img);
    }
  }

  // Inside playerSprites
  playerSprites.attack = {};
  playerSprites.attackshadow = {};
  for(const deg of DIRECTIONS){
      const d = pad(deg);
      playerSprites.attack[d] = [];
      playerSprites.attackshadow[d] = [];
      for(let i=1;i<=ATTACK_ANIM_FRAMES;i++){
          const img = new Image();
          img.src = `static/Attack/Body/${d}/Attack1_Body_${d}_${padFrame(i)}.png`;
          playerSprites.attack[d].push(img);

          const imgShadow = new Image();
          imgShadow.src = `static/Attack/Shadow/${d}/Attack1_Shadow_${d}_${padFrame(i)}.png`;
          playerSprites.attackshadow[d].push(imgShadow);
      }
  }







  /* ================= LOCAL UNITS ================= */
  // `myUnits` is declared in the globals block at the top; do not re-declare.


  for(const u of myUnits){
      u.hp = 100;           // max health
      u.targetEnemy = null;  // {sid, unitIndex} or null
      u.attackCooldown = 0;  // ms cooldown for attack ticks
      u.attackFrame = 0;     // animation frame 0-23
      u.manualMove = false; // true if user right-clicked to move
  }






  function getDirection(dx, dy) {
    const angle = Math.atan2(dy, dx); // -PI to PI
    let dir = Math.round((angle / (2 * Math.PI)) * DIRECTIONS);
    if (dir < 0) dir += DIRECTIONS;
    return dir % DIRECTIONS;
  }

  // `players` and `buildings` are declared in the globals block at the top; do not re-declare.







  /* ================= TILE ================= */
  const tile = new Image();
  tile.src = "static/grassbackground.png";
  const TILE_W = 5178;
  const TILE_H = 3009;
  const HALF_W = TILE_W/2.1;
  const HALF_H = TILE_H/2.1;


  const treeImg = new Image();
  treeImg.src = "static/tree.png";

  // Adjust to your sprite size
  const TREE_W = 250;
  const TREE_H = 250;

  // Trees will come from server

  socket.on("server_trees", serverTrees => {
      trees = serverTrees;
  });

  socket.connect();



  const COLLISION_STEP = 8;
  const COLLISION_MIN = 8;
  const COLLISION_MAX = 512;


  function mergeUnitsPreserveFrames(localUnits, serverUnits) {
    const byId = new Map(localUnits.map(u => [u.id, u]));
    const merged = [];

    for (const su0 of (serverUnits || [])) {
      const existing = byId.get(su0.id);
      const su = {
        ...su0,
        anim: su0.anim || "idle",
        dir: String(su0.dir ?? "000").padStart(3,"0"),
        hp: (su0.hp ?? existing?.hp ?? UNIT_MAX_HEALTH),
          maxHp: (su0.maxHp ?? existing?.maxHp ?? UNIT_MAX_HEALTH),
        tx:   (su0.tx ?? su0.x),
        ty:   (su0.ty ?? su0.y),
      };

      let lu = byId.get(su.id);
  if (!lu) {
    lu = {
      ...su,
      frame: 0,
      attackFrame: 0,
      renderFrame: 0,
      renderAttackFrame: 0,
      lastX: su.x,
      lastY: su.y,
      selected: false,
      manualMove: false,

      // ✅ ADD THESE
      targetEnemy: null,
      attackCooldown: ATTACK_COOLDOWN, // allow immediate attack
      harvesting: null,
    };
  } else {
        // update authoritative fields
        lu.x = su.x; lu.y = su.y;
        lu.tx = su.tx; lu.ty = su.ty;
        lu.hp = su.hp;
        lu.maxHp = su.maxHp;
        lu.dir = su.dir;

        if (lu.anim !== su.anim) {
          lu.anim = su.anim;
          lu.frame = 0;
          lu.attackFrame = 0;
          lu.renderFrame = 0;
          lu.renderAttackFrame = 0;
        }
      }
      merged.push(lu);
    }

    return merged;
  }



  /* ================= RESOURCES ================= */
  const RESOURCE_RADIUS = 40;
  const HARVEST_TIME = 10000; // ms

  const RESOURCE_STOP_RADIUS    = PLAYER_RADIUS + RESOURCE_RADIUS_COLLIDE + 1; // 36
  const RESOURCE_HARVEST_RADIUS = RESOURCE_STOP_RADIUS + 4;                    // 40



  resources = resources || [];          // {id, x, y}
  const resourceImg = new Image();
  resourceImg.src = "static/resource.png";
  const RES_W = 48;
  const RES_H = 48;

  resourceCounts = resourceCounts || { red: 0, green: 0, blue: 0 };
  hoveredResource = hoveredResource || null;

  hoveredPlayerSid = hoveredPlayerSid || null;  

  function spawnResources(){
    const cols = 69;
    const rows = 53;
    const spacing = 180;

    // start ids after any existing resources to avoid collisions
    let nextId = 0;
    if (resources && resources.length) {
      nextId = Math.max(...resources.map(rr => rr.id || 0)) + 1;
    }

    // center the grid so resources appear in both negative and positive world coordinates
    const colOffset = Math.floor(cols / 2);
    const rowOffset = Math.floor(rows / 2);

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (Math.random() < 0.6) {
          const types = ["red", "green", "blue"];
          const t = types[Math.floor(Math.random() * types.length)];

          const cc = c - colOffset;
          const rr = r - rowOffset;

          resources.push({
            id: nextId++,
            x: (cc - rr) * spacing,
            y: (cc + rr) * spacing / 2,
            type: t
          });
        }
      }
    }
  }

  /* ================= COMBAT ================= */
  const ATTACK_RANGE = 80;
  const DPS = 10; // damage per second

  let targetPlayerSid = null;

  let playerHealth = {};
  const MAX_HEALTH = 100;

  /* ================= SOCKET STATE ================= */
  // Keep player positions/colors from state
  // Update remote units

  socket.on("state", (state) => {
    console.log("STATE: before merge myUnits", myUnits.length,
              "server me.units", state.players?.[mySid]?.units?.length);

    if (state.ground_items) groundItems = state.ground_items;
    // sync authoritative resources from server
    if (state.resources) {
      resources = state.resources;
    }
    // sync map objects (for mine production timer updates)
    if (state.map_objects) {
      mapObjects = state.map_objects;
      // refresh entity inspector if open (to get updated nextTick)
      if (selectedEntityId) {
        const updated = mapObjects.find(x => x.id === selectedEntityId);
        if (updated && entityPanelEl && entityPanelEl.style.display === "block") {
          openEntityInspector(updated);
        }
      }
    }

    // ✅ FIRST: sync my own units from server (adopt server ids)
    const me = state.players?.[mySid];
    if (me && Array.isArray(me.units)) {
      myUnits = mergeUnitsPreserveFrames(myUnits, me.units);
    }
    // sync authoritative resource counts from server and advance collect quests on gains
    if (me) {
      const prevResources = { ...resourceCounts };
      resourceCounts = me.resources || { red: 0, green: 0, blue: 0 };
      window.resourceCounts = resourceCounts;
      handleResourceGain(prevResources, resourceCounts);
    }
    try { updateBuildButton(); updateMineButton(); updateBlacksmithButton(); } catch (e) {}

    for (const sid in players){
            const first = players[sid].units[0];
    if (first) { players[sid].x = first.x; players[sid].y = first.y; }
    }
    
    // existing: remove players no longer on server (but keep players that exist even if they currently have 0 units)
    for (const sid in players) {
      if (!state.players[sid]) {
        delete players[sid];
      }
    }

    // ✅ sync other players as you already do (but keep them even if units array is empty)
    for (const sid in state.players) {
      if (sid === mySid) continue;
      const sp = state.players[sid];

      if (!players[sid]) players[sid] = { x: 0, y: 0, color: "#fff", units: [] };

      players[sid].x = sp.x;
      players[sid].y = sp.y;
      players[sid].color = sp.color;

      const serverUnits = Array.isArray(sp.units) ? sp.units : [];
      players[sid].units = mergeUnitsPreserveFrames(players[sid].units || [], serverUnits);
    }

    // buildings...
    buildings = state.buildings.map(sb => {
      const existing = buildings.find(b => b.x === sb.x && b.y === sb.y && b.owner === sb.owner);
      return {
        ...sb,
        selected: existing ? existing.selected : false,
        queue: existing ? existing.queue : []
      };
    });

    groundItems = state.ground_items || [];
  });

      

    socket.on("unit_hp_update", ({ sid, unitId, hp, maxHp }) => {
      const list = sid === mySid ? myUnits : players[sid]?.units;
      if (!list) return;
      const u = list.find(u => u.id === unitId);
      if (!u) return;

      u.hp = hp;
      if (typeof maxHp === 'number') u.maxHp = maxHp;

      if (u.hp <= 0) {
          // remove locally
          const i = list.indexOf(u);
          if (i !== -1) list.splice(i, 1);
      }
  });

  socket.on("ground_items", (items) => {
    groundItems = items || [];
    // optional debug:
    // console.log("ground_items update", groundItems.length);
  });

  // also listen for direct resources broadcast
  socket.on("resources", (res) => {
    resources = res || [];
  });

  socket.on("update_units", ({ sid, units }) => {
    if (sid === mySid) return;

    // ✅ if server says this player has no units, remove them immediately
    if (!units || units.length === 0) {
      delete players[sid];
      return;
    }

    if (!players[sid]) players[sid] = { x:0, y:0, color:"#fff", units: [] };

    players[sid].units = mergeUnitsPreserveFrames(players[sid].units || [], units);

    // keep hover point synced
    const first = players[sid].units[0];
    if (first) {
      players[sid].x = first.x;
      players[sid].y = first.y;
    }
  });


  // Function to render selected units in panel
  function renderUnitPanel() {
      const unitListDiv = document.getElementById("unit-list");
      unitListDiv.innerHTML = ""; // clear

      selectedUnits.forEach(uid => {
          let unit = findUnitById(uid);
          if (!unit) return;

          const unitDiv = document.createElement("div");
          unitDiv.textContent = `Unit ${unit.id.slice(0,4)}`; // show short id
          unitDiv.style.cursor = "pointer";
          unitDiv.style.marginBottom = "5px";
          unitDiv.style.padding = "2px 5px";
          unitDiv.style.border = "1px solid white";
          unitDiv.style.borderRadius = "4px";
          unitDiv.addEventListener("click", () => {
              renderUnitItems(unit);
          });
          unitListDiv.appendChild(unitDiv);
      });
  }

  function findUnitById(uid) {
      // Prefer local units (they definitely have items)
      const local = myUnits.find(u => u.id === uid);
      if (local) return local;

      for (let sid in allUnits) {
          const unit = (allUnits[sid] || []).find(u => u.id === uid);
          if (unit) return unit;
      }
      return null;
  }


  socket.on("unit_slots_update", ({ unitId, itemSlots }) => {
    const u = myUnits.find(x => x.id === unitId);
    if (!u) return;

    u.itemSlots = itemSlots;

    // Recompute derived stats locally for immediate UI feedback
    if (typeof getUnitStats === "function") {
      const stats = getUnitStats(u);
      u.maxHp = stats.maxHp;
      if (typeof u.hp === 'number') {
        u.hp = Math.min(u.hp, u.maxHp);
      } else {
        u.hp = u.maxHp;
      }
    }

    // refresh UI if currently showing this unit
    if (currentItemsUnitId === unitId) renderUnitItems(u);
  });


  let mapObjects = []; // persistent objects from server
  let isEditingEntity = false; // flag to prevent refresh while editing
  let acceptedQuestIds = new Set();
  let questProgress = {}; // questId -> { kills: { entity: count }, collects: { entity: count } }

  try {
    const storedQuestIds = JSON.parse(localStorage.getItem("aoeAcceptedQuests") || "[]");
    if (Array.isArray(storedQuestIds)) {
      acceptedQuestIds = new Set(storedQuestIds);
    }
  } catch (err) {
    acceptedQuestIds = new Set();
  }

  try {
    const storedProgress = JSON.parse(localStorage.getItem("aoeQuestProgress") || "{}");
    if (storedProgress && typeof storedProgress === 'object') {
      questProgress = storedProgress;
    }
  } catch (err) {
    questProgress = {};
  }

  function persistQuestProgress() {
    try {
      localStorage.setItem("aoeQuestProgress", JSON.stringify(questProgress));
    } catch (err) {
      console.warn("Failed to persist quest progress", err);
    }
  }

  function getQuestProgress(questId) {
    const base = questProgress[questId] || { kills: {}, collects: {} };
    if (!base.kills) base.kills = {};
    if (!base.collects) base.collects = {};
    return base;
  }

  function incrementQuestKill(questId, entityKind) {
    if (!questProgress[questId]) {
      questProgress[questId] = { kills: {}, collects: {} };
    }
    if (!questProgress[questId].kills) {
      questProgress[questId].kills = {};
    }
    if (!questProgress[questId].collects) {
      questProgress[questId].collects = {};
    }
    questProgress[questId].kills[entityKind] = (questProgress[questId].kills[entityKind] || 0) + 1;
    persistQuestProgress();
    syncQuestLogUI();
  }

  function incrementQuestCollect(questId, entityKind, amount) {
    if (!questProgress[questId]) {
      questProgress[questId] = { kills: {}, collects: {} };
    }
    if (!questProgress[questId].collects) {
      questProgress[questId].collects = {};
    }
    if (!questProgress[questId].kills) {
      questProgress[questId].kills = {};
    }
    questProgress[questId].collects[entityKind] = (questProgress[questId].collects[entityKind] || 0) + amount;
    persistQuestProgress();
    syncQuestLogUI();
  }

  function handleResourceGain(prevResources, nextResources) {
    const resourceTypes = ["red", "green", "blue"];
    for (const type of resourceTypes) {
      const prevVal = (prevResources && prevResources[type]) || 0;
      const nextVal = (nextResources && nextResources[type]) || 0;
      const delta = nextVal - prevVal;
      if (delta <= 0) continue;

      for (const questId of acceptedQuestIds) {
        const questGiver = mapObjects.find(obj => obj.id === questId);
        if (!questGiver) continue;
        const quest = parseQuestFromBio(questGiver.meta?.bio);
        if (!quest || quest.type !== 'Collect') continue;

        const questTarget = normalizeCollectTarget(quest.params.entity);
        const resourceKey = normalizeCollectTarget(type);
        if (questTarget && questTarget === resourceKey) {
          incrementQuestCollect(questId, questTarget, delta);
        }
      }
    }
  }

  function normalizeCollectTarget(entity) {
    const clean = (entity || "").toString().trim().toLowerCase();
    if (!clean) return "";
    if (clean.endsWith(" resource")) return clean.replace(/\s*resource$/, "").trim();
    return clean;
  }

  function isQuestComplete(obj) {
    const quest = parseQuestFromBio(obj?.meta?.bio);
    if (!quest) return false;
    const progress = getQuestProgress(obj.id);

    if (quest.type === 'Kill') {
      const target = quest.params.n || 0;
      const entity = quest.params.entity || '';
      const current = progress.kills[entity] || 0;
      return current >= target;
    }

    if (quest.type === 'Collect') {
      const target = quest.params.n || 0;
      const entity = normalizeCollectTarget(quest.params.entity);
      const current = progress.collects[entity] || 0;
      return current >= target;
    }

    return false;
  }

  const questLogToggleBtn = document.getElementById("questLogToggle");
  const questLogToggleLabel = document.getElementById("questLogToggleLabel");
  const questLogToggleCount = document.getElementById("questLogToggleCount");
  const questLogPanel = document.getElementById("questLogPanel");
  const questLogList = document.getElementById("questLogList");
  const questLogCountEl = document.getElementById("questLogCount");
  const questDialogOverlay = document.getElementById("questDialog");
  const questDialogTitle = document.getElementById("questDialogTitle");
  const questDialogType = document.getElementById("questDialogType");
  const questDialogSummary = document.getElementById("questDialogSummary");
  const questDialogRewards = document.getElementById("questDialogRewards");
  const questAcceptBtn = document.getElementById("questAcceptBtn");
  const questDeclineBtn = document.getElementById("questDeclineBtn");
  const questDialogCloseBtn = document.getElementById("questDialogClose");
  let questLogVisible = false;
  let questDialogEntityId = null;

  function persistAcceptedQuests() {
    try {
      localStorage.setItem("aoeAcceptedQuests", JSON.stringify(Array.from(acceptedQuestIds)));
    } catch (err) {
      console.warn("Failed to persist quests", err);
    }
  }

  function questGiverEntities() {
    return (mapObjects || []).filter(o => o?.meta?.givesQuest);
  }

  function acceptedQuestEntities() {
    return questGiverEntities().filter(o => acceptedQuestIds.has(o.id));
  }

  function describeQuest(obj) {
    const quest = parseQuestFromBio(obj.meta?.bio);
    if (!quest) {
      const trimmed = (obj.meta?.bio || "").trim();
      return trimmed ? trimmed.slice(0, 160) : "Speak with this NPC to learn their task.";
    }
    
    // Show progress for kill quests
    if (quest.type === 'Kill' && quest.params.n && quest.params.entity) {
      const progress = getQuestProgress(obj.id);
      const current = progress.kills[quest.params.entity] || 0;
      const target = quest.params.n;
      const entityName = quest.params.entity.charAt(0).toUpperCase() + quest.params.entity.slice(1);
      return `Kill ${entityName}s: ${current}/${target}`;
    }

    // Show progress for collect quests
    if (quest.type === 'Collect' && quest.params.n && quest.params.entity) {
      const progress = getQuestProgress(obj.id);
      const entityKey = normalizeCollectTarget(quest.params.entity);
      const current = progress.collects[entityKey] || 0;
      const target = quest.params.n;
      const label = quest.params.entity;
      return `Collect ${label}: ${current}/${target}`;
    }
    
    const params = Object.entries(quest.params || {})
      .map(([k, v]) => `${k}: ${v}`)
      .join(" · ");
    return params ? `${quest.type} — ${params}` : quest.type;
  }

  function rebuildQuestLogList() {
    if (!questLogList) return;
    questLogList.innerHTML = "";
    const quests = acceptedQuestEntities();
    if (quests.length === 0) {
      const empty = document.createElement("div");
      empty.className = "quest-log-empty";
      empty.textContent = "No accepted quests yet. Talk to a quest giver and accept their offer to track it here.";
      questLogList.appendChild(empty);
      return;
    }

    quests
      .slice()
      .sort((a, b) => (a.meta?.title || a.kind || "").localeCompare(b.meta?.title || b.kind || ""))
      .forEach(obj => {
        const card = document.createElement("div");
        card.className = "quest-log-item";

        const titleEl = document.createElement("div");
        titleEl.className = "quest-log-title";
        titleEl.textContent = obj.meta?.title || getDefaultEntityTitle(obj);
        card.appendChild(titleEl);

        const summaryEl = document.createElement("div");
        summaryEl.className = "quest-log-summary";
        const description = describeQuest(obj);
        const complete = isQuestComplete(obj);
        summaryEl.textContent = description;
        if (complete) {
          summaryEl.style.color = "#4ade80";
          summaryEl.textContent += " ✓ COMPLETE";
        }
        card.appendChild(summaryEl);

        const coordsEl = document.createElement("div");
        coordsEl.className = "quest-log-coords";
        const cx = Number.isFinite(obj.x) ? Math.round(obj.x) : 0;
        const cy = Number.isFinite(obj.y) ? Math.round(obj.y) : 0;
        coordsEl.textContent = `Near (${cx}, ${cy})`;
        card.appendChild(coordsEl);

        card.addEventListener("click", () => {
          openEntityInspector(obj);
        });

        questLogList.appendChild(card);
      });
  }

  function syncQuestLogUI() {
    const total = acceptedQuestEntities().length;
    if (questLogCountEl) questLogCountEl.textContent = `${total} quest${total === 1 ? "" : "s"}`;
    if (questLogToggleCount) questLogToggleCount.textContent = String(total);
    if (questLogToggleLabel) questLogToggleLabel.textContent = questLogVisible ? "Hide Quest Log" : "Quest Log";
    if (questLogVisible) rebuildQuestLogList();
  }

  function setQuestLogVisibility(visible) {
    questLogVisible = !!visible;
    if (questLogPanel) questLogPanel.style.display = questLogVisible ? "block" : "none";
    if (questLogToggleBtn) questLogToggleBtn.classList.toggle("active", questLogVisible);
    syncQuestLogUI();
  }

  if (questLogToggleBtn) {
    questLogToggleBtn.addEventListener("click", () => {
      setQuestLogVisibility(!questLogVisible);
    });
  }

  function questRewardsForEntity(obj) {
    if (!obj) return [];
    if (!Array.isArray(obj.itemSlots)) return [];
    return obj.itemSlots.filter(slot => slot && typeof slot === "object");
  }

  function rewardLabel(item) {
    if (!item || typeof item !== "object") return "Mystery Item";
    const name = item.name || "Item";
    const bonus = (item.bonus !== undefined && item.bonus !== null && item.bonus !== "") ? ` +${item.bonus}` : "";
    return { name, bonus: bonus }; // return structured to avoid string concat later
  }

  function fillQuestDialogRewards(obj) {
    if (!questDialogRewards) return;
    questDialogRewards.innerHTML = "";
    const rewards = questRewardsForEntity(obj);
    if (rewards.length === 0) {
      const li = document.createElement("li");
      li.textContent = "No rewards listed";
      questDialogRewards.appendChild(li);
      return;
    }
    rewards.forEach(item => {
      const li = document.createElement("li");
      const label = rewardLabel(item);
      const spanName = document.createElement("span");
      spanName.className = "quest-dialog-reward-name";
      spanName.textContent = label.name;
      const spanBonus = document.createElement("span");
      spanBonus.className = "quest-dialog-reward-bonus";
      spanBonus.textContent = label.bonus;
      if (!label.bonus) spanBonus.style.display = "none";
      li.appendChild(spanName);
      li.appendChild(spanBonus);
      questDialogRewards.appendChild(li);
    });
  }

  function closeQuestDialog() {
    questDialogEntityId = null;
    if (questDialogOverlay) questDialogOverlay.style.display = "none";
  }

  function showQuestDialog(obj) {
    if (!obj || !questDialogOverlay) return;
    ensureEntityMeta(obj);
    questDialogEntityId = obj.id;
    const quest = parseQuestFromBio(obj.meta?.bio);
    if (questDialogTitle) questDialogTitle.textContent = obj.meta?.title || getDefaultEntityTitle(obj);
    if (questDialogType) {
      const typeLabel = quest?.type ? `${quest.type} Quest` : "Quest Details";
      questDialogType.textContent = typeLabel;
    }
    if (questDialogSummary) questDialogSummary.textContent = describeQuest(obj);
    fillQuestDialogRewards(obj);

    const alreadyAccepted = acceptedQuestIds.has(obj.id);
    if (questAcceptBtn) {
      questAcceptBtn.disabled = alreadyAccepted;
      questAcceptBtn.textContent = alreadyAccepted ? "Quest Accepted" : "Accept Quest";
    }
    if (questDialogOverlay) questDialogOverlay.style.display = "flex";
  }

  window.showQuestDialog = showQuestDialog;

  if (questDialogCloseBtn) questDialogCloseBtn.addEventListener("click", closeQuestDialog);
  if (questDeclineBtn) questDeclineBtn.addEventListener("click", closeQuestDialog);
  if (questDialogOverlay) {
    questDialogOverlay.addEventListener("click", (e) => {
      if (e.target === questDialogOverlay) closeQuestDialog();
    });
  }

  if (questAcceptBtn) {
    questAcceptBtn.addEventListener("click", () => {
      if (!questDialogEntityId) return;
      acceptedQuestIds.add(questDialogEntityId);
      persistAcceptedQuests();
      
      // Initialize quest progress if it's a kill or collect quest
      const obj = mapObjects.find(o => o.id === questDialogEntityId);
      if (obj) {
        const quest = parseQuestFromBio(obj.meta?.bio);
        if (quest && (quest.type === 'Kill' || quest.type === 'Collect')) {
          if (!questProgress[questDialogEntityId]) {
            questProgress[questDialogEntityId] = { kills: {}, collects: {} };
          }
          if (!questProgress[questDialogEntityId].kills) questProgress[questDialogEntityId].kills = {};
          if (!questProgress[questDialogEntityId].collects) questProgress[questDialogEntityId].collects = {};

          if (quest.type === 'Kill' && quest.params.entity) {
            questProgress[questDialogEntityId].kills[quest.params.entity] = 0;
          }
          if (quest.type === 'Collect' && quest.params.entity) {
            const key = normalizeCollectTarget(quest.params.entity);
            questProgress[questDialogEntityId].collects[key] = 0;
          }
          persistQuestProgress();
        }
      }
      
      setQuestLogVisibility(true);
      closeQuestDialog();
    });
  }

  syncQuestLogUI();

  socket.on("map_objects", (objs) => {
    const inspectorOpen = (
      selectedEntityId &&
      entityPanelEl &&
      entityPanelEl.style.display === "block"
    );

    if (inspectorOpen && Array.isArray(objs)) {
      const incoming = objs.find(x => x.id === selectedEntityId);
      if (incoming) {
        ensureEntityMeta(incoming);
        // Keep local inspector edits applied client-side until save
        incoming.meta.title = entityTitleInput.value;
        incoming.meta.bio = entityBioInput.value;

        const zOrderInput = document.getElementById("entityZOrderInput");
        if (zOrderInput && zOrderInput.value !== "") {
          const zValue = parseFloat(zOrderInput.value);
          if (!Number.isNaN(zValue)) incoming.meta.z = zValue;
        }

        const questToggle = document.getElementById("entityQuestToggle");
        if (questToggle) {
          incoming.meta.givesQuest = !!questToggle.checked;
        }
      }
    }

    mapObjects = objs || [];
    const validQuestIds = new Set(questGiverEntities().map(o => o.id));
    let pruned = false;
    acceptedQuestIds.forEach((questId) => {
      if (!validQuestIds.has(questId)) {
        acceptedQuestIds.delete(questId);
        pruned = true;
      }
    });
    if (pruned) persistAcceptedQuests();
    syncQuestLogUI();
    // If entity inspector is open for an entity, refresh it only if user is not actively editing
    if (selectedEntityId && !isEditingEntity) {
      const updated = mapObjects.find(x => x.id === selectedEntityId);
      if (updated && entityPanelEl && entityPanelEl.style.display === "block") {
        openEntityInspector(updated);
      }
    }
    // update build button count/limit
    try { updateBuildButton(); updateMineButton(); updateBlacksmithButton(); } catch(e){}
  });

  // Update entity HP when server reports damage
  socket.on("entity_hp_update", ({ entityId, hp }) => {
    try {
      const o = (mapObjects || []).find(x => x.id === entityId);
      if (o) {
        const wasAlive = o.hp > 0;
        o.hp = hp;
        
        // Track quest kills when entity dies
        if (wasAlive && hp <= 0) {
          const entityKind = o.kind || o.type;
          console.log("[QUEST] Entity killed:", entityKind, entityId);
          
          // Check all accepted kill quests
          for (const questId of acceptedQuestIds) {
            const questGiver = mapObjects.find(obj => obj.id === questId);
            if (!questGiver) continue;
            
            const quest = parseQuestFromBio(questGiver.meta?.bio);
            if (quest && quest.type === 'Kill' && quest.params.entity === entityKind) {
              incrementQuestKill(questId, entityKind);
              const progress = getQuestProgress(questId);
              const current = progress.kills[entityKind] || 0;
              const target = quest.params.n || 0;
              console.log(`[QUEST] Progress: ${current}/${target} ${entityKind}s killed`);
              
              // Show notification if quest complete
              if (current >= target) {
                console.log(`[QUEST] Quest complete! Return to quest giver.`);
              }
            }
          }
        }
        
        // refresh inspector if open for this entity
        if (selectedEntityId === entityId && entityPanelEl && entityPanelEl.style.display === 'block') {
          openEntityInspector(o);
        }
      }
      console.log("SERVER_DEBUG: entity_hp_update", entityId, hp);
    } catch (e) { console.error(e); }
  });

  tile.onload = draw;
  
  // Start the animation loop once assets are loaded
  (function startDraw() {
    if (window.ASSETS_LOADED) {
      draw();
    } else {
      requestAnimationFrame(startDraw);
    }
  })();
  </script>
  </body>
  </html>