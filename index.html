  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="utf-8">
  <title>Isometric Multiplayer RTS</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; }
  canvas { display:block; }
  #hud {
    position:fixed;
    top:10px; left:10px;
    color:white;
    font-family:monospace;
    background:rgba(0,0,0,0.5);
    padding:6px;
  }
  #panel {
    position:fixed;
    bottom:20px;
    left:20px;
    width:220px;
    height:120px;
    background:rgba(30,30,30,0.85);
    border:2px solid #888;
    padding:10px;
    color:white;
    font-family:monospace;
    display:none;
  }

  #buildBtn {
    width:100%;
    height:40px;
    margin-top:10px;
    background:#444;
    color:white;
    border:1px solid #aaa;
    cursor:pointer;
  }
  #buildBtn:hover { background:#666; }
  #buildBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
  </style>
  </head>

  <body>
  <canvas id="game"></canvas>
  <div id="hud"></div>

  <div id="panel">
    <div>Unit Selected</div>
    <button id="buildBtn">Place Building</button>
  </div>

  <div id="buildingPanel" style="display:none; position:fixed; bottom:20px; left:20px; width:220px; height:120px; background:rgba(30,30,30,0.85); border:2px solid #888; padding:10px; color:white; font-family:monospace;">
    <div>Building Selected</div>
    <button id="createUnitBtn">Create Unit</button>
  </div>

  <div id="unit-panel" style="position:fixed; right:10px; top:10px; width:200px; background:rgba(0,0,0,0.7); color:white; padding:10px; border-radius:8px;">
      <h3>Selected Units</h3>
      <div id="unit-list"></div>
      <div id="unit-items" style="margin-top:10px;">
          <h4>Unit Items</h4>
          <ul id="items-list"></ul>
      </div>
  </div>

  <div id="editorPanel" style="
    position:fixed;
    right:10px;
    bottom:10px;
    width:240px;
    background:rgba(0,0,0,0.75);
    color:white;
    padding:10px;
    border-radius:8px;
    font-family:monospace;
    z-index:1000;
  ">
    <button id="editorBtn" style="width:100%; height:36px;">Editor: OFF</button>
  <div style="margin-top:10px;">
    <div>Brush:</div>
    <select id="brushSelect" style="width:100%; height:30px;">
      <option value="" disabled selected>Loading tiles…</option>
    </select>
    <div style="margin-top:10px; font-size:12px; opacity:0.9;">
      Left click: place<br/>
      Shift+Left click: delete<br/>
      c: toggle collision<br/>
      Scroll: collision size<br/>
      Shift+Scroll: tile size 
    </div>
    <button id="entityBtn" style="width:100%; height:36px; margin-top:8px;">
    Entity: OFF
  </button>
  </div>
  </div>
  <div id="entityPanel" style="
    display:none;
    position:fixed;
    left:20px;
    bottom:160px;
    width:320px;
    background:rgba(0,0,0,0.85);
    color:white;
    padding:12px;
    border-radius:10px;
    border:2px solid #777;
    font-family:monospace;
    z-index:2000;
  ">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:bold;">Entity Inspector</div>
      <button id="entityCloseBtn" style="height:26px;">X</button>
    </div>

    <div style="margin-top:10px; font-size:12px; opacity:0.8;" id="entityIdLine"></div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Title</div>
      <input id="entityTitleInput" style="width:100%; height:30px;"/>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Biography</div>
      <textarea id="entityBioInput" style="width:100%; height:90px;"></textarea>
    </div>

    <div style="margin-top:10px;">
      <div style="display:flex; gap:8px; align-items:center;">
        <div style="font-size:12px; opacity:0.8; flex:1;">Actions</div>
        <button id="entityAddActionBtn" style="height:26px;">+ Add</button>
      </div>
      <div id="entityActionsList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:6px;"></div>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Items</div>
      <ul id="entity-items-list" style="margin-top:6px; list-style:none; padding:0;"></ul>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Abilities</div>
      <div id="entity-abilities-list" style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;"></div>
    </div>

    <div style="margin-top:10px; display:flex; gap:8px;">
      <button id="entitySaveBtn" style="flex:1; height:34px;">Save</button>
      <button id="entityDeleteBtn" style="flex:1; height:34px;">Delete</button>
    </div>
  </div>




  <script>
  const canvas = document.getElementById("game");
  // Loading overlay + image loader instrumentation
  (function(){
    const overlay = document.createElement('div');
    overlay.id = 'loadingOverlay';
    overlay.style.position = 'fixed';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.right = '0';
    overlay.style.bottom = '0';
    overlay.style.background = '#000';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.zIndex = '99999';
    overlay.style.flexDirection = 'column';
    overlay.style.color = 'white';
    overlay.innerHTML = `
      <div style="font-family:monospace; font-size:18px; margin-bottom:12px;">Loading assets...</div>
      <div style="width:60%; max-width:520px; background:rgba(255,255,255,0.08); padding:6px; border-radius:6px;">
        <div id="loadingBarInner" style="height:18px; width:0%; background:linear-gradient(90deg,#4ee,#08f); border-radius:4px;"></div>
      </div>
      <div id="loadingPercent" style="font-family:monospace; margin-top:8px; opacity:0.9;">0%</div>
    `;
    document.body.appendChild(overlay);

    window.__loader = {
      total: 0,
      loaded: 0,
      errored: 0,
      _lastChange: Date.now(),
      _checkTimer: null,
      update() {
        const inner = document.getElementById('loadingBarInner');
        const pctEl = document.getElementById('loadingPercent');
        const total = Math.max(1, this.total);
        const done = Math.min(this.loaded + this.errored, total);
        const pct = Math.floor((done / total) * 100);
        if (inner) inner.style.width = pct + '%';
        if (pctEl) pctEl.textContent = pct + '%';

        // If everything loaded right now, wait a short quiescence period
        // to allow any late Image() constructions to register.
        if (done >= this.total) {
          const now = Date.now();
          const sinceChange = now - (this._lastChange || 0);
          const QUIESCE = 400; // ms
          clearTimeout(this._checkTimer);
          if (sinceChange >= QUIESCE) {
            window.ASSETS_LOADED = true;
            setTimeout(() => { overlay.style.display = 'none'; }, 120);
          } else {
            // schedule a recheck after the remaining quiesce interval
            this._checkTimer = setTimeout(() => this.update(), QUIESCE - sinceChange + 10);
          }
        }
      }
    };

    // Monkeypatch Image to auto-register loads
    const NativeImage = window.Image;
    function LoaderImage() {
      const img = new NativeImage();
      try { window.__loader.total++; window.__loader._lastChange = Date.now(); } catch(e){}
      img.addEventListener('load', function(){ try{ window.__loader.loaded++; window.__loader.update(); }catch(e){} });
      img.addEventListener('error', function(){ try{ window.__loader.errored++; window.__loader.update(); }catch(e){} });
      return img;
    }
    LoaderImage.prototype = NativeImage.prototype;
    window.Image = LoaderImage;
    // start as not loaded
    window.ASSETS_LOADED = false;
  })();
  let editorMode = false;
  let editorTileW = 256;
  let editorTileH = 256;
  let editorTileAspect = 1;
  let editorTileOverride = false;
  let editorCollisionEnabled = true;
  let editorCollisionW = 64;
  let editorCollisionH = 64;

  // Global variables
  let camera = {x:0,y:0};
  let groundItems = [];
  let trees = [];
  let resources = [];
  let buildings = [];
  let myUnits = [];
  let players = {};
  let resourceCount = 0;
  let hoveredResource = null;
  let hoveredPlayerSid = null;
  let dragMouse = {x:0,y:0};
  let selecting = false;
  let selectStart = {x:0,y:0};
  let mouse = {x:0,y:0};
  let buildMode = false;
  let localBuildingPlaced = false;
  const socket = io({autoConnect: false});
  socket.on("server_debug", (data) => { try { console.log("SERVER_DEBUG:", data.msg); } catch(e){} });
  // Building image and default size (needed by static/draw.js)
  const BUILD_W = 256;
  const BUILD_H = 256;
  const buildingImg = new Image();
  buildingImg.src = "static/tiles/building.png";
  </script>

  <script src="static/input.js"></script>
  <script src="static/update.js"></script>
  <script src="static/draw.js"></script>
  <script src="static/editor.js"></script>

  <script>
  /* ================= SETUP ================= */
  const ctx = canvas.getContext("2d");
  const hud = document.getElementById("hud");
  const panel = document.getElementById("panel");
  const buildBtn = document.getElementById("buildBtn");

  // Entity inspector elements (used by openEntityInspector / input handlers)
  const entityPanelEl = document.getElementById("entityPanel");
  const entityIdLine = document.getElementById("entityIdLine");
  const entityTitleInput = document.getElementById("entityTitleInput");
  const entityBioInput = document.getElementById("entityBioInput");
  const entityAddActionBtn = document.getElementById("entityAddActionBtn");
  const entityActionsList = document.getElementById("entityActionsList");
  const entitySaveBtn = document.getElementById("entitySaveBtn");
  const entityDeleteBtn = document.getElementById("entityDeleteBtn");
  const entityCloseBtn = document.getElementById("entityCloseBtn");

  let selectedEntityId = null;
  let draggingPickup = null;

  if (entityCloseBtn) {
    entityCloseBtn.onclick = () => {
      if (entityPanelEl) entityPanelEl.style.display = "none";
      selectedEntityId = null;
    };
  }

  let mySid = null;
  socket.on("connect", () => {
    mySid = socket.id;

    // ✅ request initial map after connection is established
    socket.emit("request_state");
    socket.emit("request_map");
  });


  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  let DEBUG_COLLISIONS = true; // toggle on/off


  function setEntityInspectorEditable(canEdit) {
    entityTitleInput.disabled = !canEdit;
    entityBioInput.disabled = !canEdit;

    entityAddActionBtn.disabled = !canEdit;
    entitySaveBtn.disabled = !canEdit;
    entityDeleteBtn.disabled = !canEdit;

    // Optional visual cue
    entityTitleInput.style.opacity = canEdit ? "1" : "0.7";
    entityBioInput.style.opacity   = canEdit ? "1" : "0.7";
  }


  /* ================= PLAYER SPRITES ================= */

  const SPRITE_W = 256;
  const SPRITE_H = 256;
  const DIRECTIONS = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337];
  const IDLE_FRAMES = 24;
  const WALK_FRAMES = 24;
  const ANIM_SPEED = 0.3;


  const UNIT_RADIUS = 18;
  const PLAYER_RADIUS = 20;
  const TREE_RADIUS = 140;
  const RESOURCE_RADIUS_COLLIDE = 15;

  // Buildings use rectangle collision
  const BUILD_COLLISION_PADDING = -50;


  const UNIT_ATTACK_RANGE = PLAYER_RADIUS + UNIT_RADIUS + 10; // 10 extra for buffer
  const UNIT_ATTACK_DPS = 30; // damage per second
  const ATTACK_COOLDOWN = 1000 / 60; // 1 tick per frame (60fps)
  const UNIT_MAX_HEALTH = 100;
  const ATTACK_ANIM_FRAMES = 24;


  // groundItems declared earlier in the global setup

  const itemIcons = {
    sword: new Image(),
    shield: new Image()
  };
  itemIcons.sword.src = "static/items/sword.png";   // make these files
  itemIcons.shield.src = "static/items/shield.png"; // or draw text fallback
  const GROUND_ITEM_SIZE = 32;
  const PICKUP_RADIUS = 26;

  const PICKUP_DISTANCE = 120; // how close unit must be to pick up from ground
  let currentItemsUnitId = null; // which unit's equipment UI is currently showing


  function unitCanPickup(unit, groundItem) {
    return Math.hypot(unit.x - groundItem.x, unit.y - groundItem.y) <= PICKUP_DISTANCE;
  }

  
  // `draggingPickup` and `dragMouse` are declared in the main globals block; do not re-declare here.


  function getFirstSelectedUnit() {
    return myUnits.find(u => u.selected) || null;
  }
  function onGlobalDragMove(e) {
    // keep mouse updated even over UI
    dragMouse.x = e.clientX;
    dragMouse.y = e.clientY;

    // optional: block text selection while dragging
    e.preventDefault();
  }

  function onGlobalDragEnd(e) {
    // stop capturing
    window.removeEventListener("mousemove", onGlobalDragMove, true);
    window.removeEventListener("mouseup", onGlobalDragEnd, true);

    if (!draggingPickup) return;

    const gi = groundItems.find(x => x.id === draggingPickup.groundItemId);
    const picker = myUnits.find(u => u.id === draggingPickup.unitId);
    draggingPickup = null;

    if (!gi || !picker) return;

    // must still be in range
    if (!unitCanPickup(picker, gi)) return;

    // must drop on a slot
    const slotEl = findSlotElementAtScreen(e.clientX, e.clientY);
    if (!slotEl) return;

    const slotIndex = parseInt(slotEl.dataset.slotIndex, 10);
    const unitId = slotEl.dataset.unitId;

    const targetUnit = myUnits.find(u => u.id === unitId);
    if (!targetUnit) return;

    if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null];
    if (targetUnit.itemSlots[slotIndex]) return; // must be empty

    socket.emit("pickup_item", {
      unitId: targetUnit.id,
      slotIndex,
      groundItemId: gi.id
    });
  }


  function renderUnitItems(unit) {
    currentItemsUnitId = unit.id;

    const itemsList = document.getElementById("items-list");
    itemsList.innerHTML = "";

    if (!unit.itemSlots) unit.itemSlots = [null, null];

    for (let i = 0; i < 2; i++) {
      const slot = unit.itemSlots[i];

      const li = document.createElement("li");
      li.style.display = "flex";
      li.style.alignItems = "center";
      li.style.justifyContent = "space-between";
      li.style.border = "1px solid #777";
      li.style.borderRadius = "6px";
      li.style.padding = "6px";
      li.style.marginBottom = "6px";
      li.style.background = "rgba(255,255,255,0.05)";

      li.dataset.slotIndex = String(i);
      li.dataset.unitId = unit.id;

      const left = document.createElement("div");
      left.textContent = `Slot ${i + 1}: ${slot ? slot.name : "(empty)"}`;
      li.appendChild(left);

      // Allow dropping from ground -> slot OR slot -> slot
      li.addEventListener("dragover", (e) => {
        e.preventDefault();
        li.style.outline = "2px dashed #fff";
      });
      li.addEventListener("dragleave", () => {
        li.style.outline = "";
      });

      li.addEventListener("drop", (e) => {
        e.preventDefault();
        li.style.outline = "";

        const payloadStr = e.dataTransfer.getData("application/json");
        if (!payloadStr) return;

        let payload;
        try { payload = JSON.parse(payloadStr); } catch { return; }

        const targetUnit = myUnits.find(u => u.id === unit.id);
        if (!targetUnit) return;
        if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null];

        const slotIndex = i;

    if (payload.type === "ground_item") {
      socket.emit("pickup_item", {
        unitId: unit.id,
        slotIndex: i,
        groundItemId: payload.groundItemId
      });
      return;
    }

        // If dropping an entity item onto a unit slot
        if (payload.type === "entity_item") {
          // payload: { type: 'entity_item', entityId, slotIndex, item }
          socket.emit("entity_give_to_unit", {
            entityId: payload.entityId,
            entitySlotIndex: payload.slotIndex,
            unitId: unit.id,
            slotIndex: i
          });
          return;
        }

        // If dropping a unit item (slot -> slot) (optional nice feature):
        if (payload.type === "unit_item") {
          const fromUnit = myUnits.find(u => u.id === payload.unitId);
          if (!fromUnit || !fromUnit.itemSlots) return;

          const fromSlot = payload.slotIndex;
          const moving = fromUnit.itemSlots[fromSlot];
          if (!moving) return;

          // If target slot occupied, swap
          const temp = targetUnit.itemSlots[slotIndex];
          targetUnit.itemSlots[slotIndex] = moving;
          fromUnit.itemSlots[fromSlot] = temp || null;

          renderUnitItems(targetUnit);
          return;
        }
      });

      // If slot has item: make it draggable out
      if (slot) {
        const chip = document.createElement("div");
        chip.textContent = "drag";
        chip.style.padding = "3px 8px";
        chip.style.border = "1px solid #aaa";
        chip.style.borderRadius = "6px";
        chip.style.cursor = "grab";
        chip.style.userSelect = "none";
        chip.style.background = "rgba(0,0,0,0.3)";
        chip.draggable = true;

        chip.addEventListener("dragstart", (e) => {
          const payload = {
            type: "unit_item",
            unitId: unit.id,
            slotIndex: i,
            item: slot
          };
          e.dataTransfer.setData("application/json", JSON.stringify(payload));
          e.dataTransfer.effectAllowed = "move";
        });

        li.appendChild(chip);
      }

      itemsList.appendChild(li);
    }
  }




  canvas.addEventListener("dragover", (e) => {
    e.preventDefault(); // allow drop
  });

  canvas.addEventListener("drop", (e) => {
    e.preventDefault();

    const payloadStr = e.dataTransfer.getData("application/json");
    if (!payloadStr) return;

    let payload;
    try { payload = JSON.parse(payloadStr); } catch { return; }

    // Convert screen -> world
    const wx = camera.x + e.clientX - canvas.width / 2;
    const wy = camera.y + e.clientY - canvas.height / 2;

    // Dropping equipment item onto world => SERVER creates ground item
    if (payload.type === "unit_item") {
      socket.emit("drop_item", {
        unitId: payload.unitId,
        slotIndex: payload.slotIndex,
        x: wx,
        y: wy
      });
      return;
    }
  });




  function ensureEntityMeta(o) {
    if (!o.meta) o.meta = {};
    if (!o.meta.entity) o.meta.entity = true;
    if (typeof o.meta.title !== "string") o.meta.title = "";
    if (typeof o.meta.bio !== "string") o.meta.bio = "";
    if (!Array.isArray(o.meta.actions)) o.meta.actions = [];
  }

  function getDefaultEntityTitle(o) {
    if (o.type === "building") return "Building";
    if (o.type === "tile") return o.kind ? prettyName(o.kind) : "Tile";
    return "Entity";
  }

  function openEntityInspector(o) {
    ensureEntityMeta(o);
    selectedEntityId = o.id;

    entityIdLine.textContent =
      `id: ${o.id} | type: ${o.type}${o.kind ? " | kind: " + o.kind : ""}`;

    entityTitleInput.value = o.meta.title || getDefaultEntityTitle(o);
    entityBioInput.value = o.meta.bio || "";

    renderEntityActions(o);

    // ✅ Only allow editing TILE title/bio when editor mode is ON
    const isTile = (o.type === "tile");
    const canEdit = !(isTile && !editorMode);
    setEntityInspectorEditable(canEdit);

    // Optional: make it obvious why it's locked
    if (!canEdit) {
      entityIdLine.textContent += "  |  (read-only: enable Editor to edit tile text)";
    }

    // Render entity item slots
    const entityItemsEl = document.getElementById("entity-items-list");
    if (entityItemsEl) {
      entityItemsEl.innerHTML = "";
      const slots = o.itemSlots || [];
      for (let si = 0; si < Math.max(2, slots.length); si++) {
        const s = slots[si] || null;
        const li = document.createElement("li");
        li.style.display = "flex";
        li.style.justifyContent = "space-between";
        li.style.alignItems = "center";
        li.style.border = "1px solid #666";
        li.style.padding = "6px";
        li.style.marginBottom = "6px";
        li.dataset.slotIndex = si;
        li.dataset.entityId = o.id;

        const left = document.createElement("div");
        left.textContent = `Slot ${si+1}: ${s ? s.name : "(empty)"}`;
        li.appendChild(left);

        // allow dropping unit_item onto entity slot
        li.addEventListener("dragover", (e) => { e.preventDefault(); li.style.outline = "2px dashed #fff"; });
        li.addEventListener("dragleave", () => { li.style.outline = ""; });
        li.addEventListener("drop", (e) => {
          e.preventDefault(); li.style.outline = "";
          const payloadStr = e.dataTransfer.getData("application/json");
          if (!payloadStr) return;
          let payload; try { payload = JSON.parse(payloadStr); } catch { return; }
          // dropping a unit item onto entity
          console.log("entity-slot drop", { entityId: o.id, slotIndex: si, payload });
          if (payload.type === "unit_item") {
            socket.emit("unit_give_to_entity", {
              unitId: payload.unitId,
              unitSlotIndex: payload.slotIndex,
              entityId: o.id,
              entitySlotIndex: si
            });
          }
        });

        // if slot has item, make draggable
        if (s) {
          const chip = document.createElement("div");
          chip.textContent = s.name || "item";
          chip.style.padding = "3px 8px";
          chip.style.border = "1px solid #aaa";
          chip.style.borderRadius = "6px";
          chip.style.cursor = "grab";
          chip.draggable = true;
          chip.addEventListener("dragstart", (e) => {
            const payload = { type: "entity_item", entityId: o.id, slotIndex: si, item: s };
            e.dataTransfer.setData("application/json", JSON.stringify(payload));
            e.dataTransfer.effectAllowed = "move";
          });
          li.appendChild(chip);
        }

        entityItemsEl.appendChild(li);
      }
    }

      // Render Abilities
      const abilitiesEl = document.getElementById("entity-abilities-list");
      if (abilitiesEl) {
        abilitiesEl.innerHTML = "";
        // Only town_center entities have spawn ability
        const isTownCenter = (o.kind === "town_center" || (o.meta && o.meta.kind === "town_center"));
        if (isTownCenter) {
          const btn = document.createElement("button");
          btn.textContent = "Spawn Unit";
          btn.style.height = "30px";
          btn.onclick = () => {
            if (!o || !o.id) return;
            socket.emit("spawn_unit_from_entity", { entityId: o.id });
          };
          abilitiesEl.appendChild(btn);
        }
      }

      entityPanelEl.style.display = "block";
  }

  function renderEntityActions(o) {
    entityActionsList.innerHTML = "";
    ensureEntityMeta(o);

    for (let i = 0; i < o.meta.actions.length; i++) {
      const a = o.meta.actions[i];

      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.gap = "4px";
      wrap.style.alignItems = "center";

      const btn = document.createElement("button");
      btn.textContent = a.label || `Action ${i+1}`;
      btn.style.height = "26px";

      // Clicking action in inspector triggers an event (so you can hook gameplay)
      btn.onclick = () => {
        socket.emit("entity_action", { entityId: o.id, actionId: a.id, label: a.label });
        // optional local feedback:
        // console.log("entity_action", o.id, a);
      };

      const del = document.createElement("button");
      del.textContent = "✕";
      del.style.height = "26px";
      del.onclick = () => {
        o.meta.actions.splice(i, 1);
        renderEntityActions(o);
      };

      wrap.appendChild(btn);
      wrap.appendChild(del);
      entityActionsList.appendChild(wrap);
    }
  }
  entityAddActionBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    // If tile + editor off => no edits
    if (o.type === "tile" && !editorMode) return;

    ensureEntityMeta(o);

    const label = prompt("Action label?", "Inspect");
    if (!label) return;

    o.meta.actions.push({ id: crypto.randomUUID(), label });
    renderEntityActions(o);
  };


  entitySaveBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    if (o.type === "tile" && !editorMode) return;

    ensureEntityMeta(o);
    o.meta.title = entityTitleInput.value || "";
    o.meta.bio = entityBioInput.value || "";
    socket.emit("update_map_object", { id: o.id, meta: o.meta });
    entityPanelEl.style.display = "none";
  };

  entityDeleteBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    if (o.type === "tile" && !editorMode) return;

    socket.emit("delete_map_object", { id: selectedEntityId });
    entityPanelEl.style.display = "none";
    selectedEntityId = null;
  };




  const playerSprites = {
    idle: {},
    walk: {},
    idleshadow:{},
    walkshadow:{},
  };

  function pad(num, length=3) { return num.toString().padStart(length, "0"); }
  function padFrame(num, length=4) { return num.toString().padStart(length, "0"); }



  for (const deg of DIRECTIONS) {
    const d = pad(deg);

    playerSprites.idle[d] = [];
    playerSprites.walk[d] = [];
    playerSprites.idleshadow[d] = [];
    playerSprites.walkshadow[d] = [];

    // Idle frames
    for (let i = 1; i <= IDLE_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Idle/Body/${d}/Idle_Body_${d}_${padFrame(i)}.png`;
      playerSprites.idle[d].push(img);
      const imgshadow = new Image();
      imgshadow.src = `static/Idle/Shadow/${d}/Idle_Shadow_${d}_${padFrame(i)}.png`;
      playerSprites.idleshadow[d].push(imgshadow);
    }

    // Walk frames
    for (let i = 1; i <= WALK_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Run/Body/${d}/Run_Body_${d}_${padFrame(i)}.png`;
      playerSprites.walk[d].push(img);
      const imgshadow = new Image();
      imgshadow.src = `static/Run/Shadow/${d}/Run_Shadow_${d}_${padFrame(i)}.png`;
      playerSprites.walkshadow[d].push(imgshadow);
    }
  }

  // Inside playerSprites
  playerSprites.attack = {};
  playerSprites.attackshadow = {};
  for(const deg of DIRECTIONS){
      const d = pad(deg);
      playerSprites.attack[d] = [];
      playerSprites.attackshadow[d] = [];
      for(let i=1;i<=ATTACK_ANIM_FRAMES;i++){
          const img = new Image();
          img.src = `static/Attack/Body/${d}/Attack1_Body_${d}_${padFrame(i)}.png`;
          playerSprites.attack[d].push(img);

          const imgShadow = new Image();
          imgShadow.src = `static/Attack/Shadow/${d}/Attack1_Shadow_${d}_${padFrame(i)}.png`;
          playerSprites.attackshadow[d].push(imgShadow);
      }
  }







  /* ================= LOCAL UNITS ================= */
  // `myUnits` is declared in the globals block at the top; do not re-declare.


  for(const u of myUnits){
      u.hp = 100;           // max health
      u.targetEnemy = null;  // {sid, unitIndex} or null
      u.attackCooldown = 0;  // ms cooldown for attack ticks
      u.attackFrame = 0;     // animation frame 0-23
      u.manualMove = false; // true if user right-clicked to move
  }






  function getDirection(dx, dy) {
    const angle = Math.atan2(dy, dx); // -PI to PI
    let dir = Math.round((angle / (2 * Math.PI)) * DIRECTIONS);
    if (dir < 0) dir += DIRECTIONS;
    return dir % DIRECTIONS;
  }

  // `players` and `buildings` are declared in the globals block at the top; do not re-declare.







  /* ================= TILE ================= */
  const tile = new Image();
  tile.src = "static/grassbackground.png";
  const TILE_W = 5178;
  const TILE_H = 3009;
  const HALF_W = TILE_W/2.1;
  const HALF_H = TILE_H/2.1;


  const treeImg = new Image();
  treeImg.src = "static/tree.png";

  // Adjust to your sprite size
  const TREE_W = 250;
  const TREE_H = 250;

  // Trees will come from server

  socket.on("server_trees", serverTrees => {
      trees = serverTrees;
  });

  socket.connect();



  const COLLISION_STEP = 8;
  const COLLISION_MIN = 8;
  const COLLISION_MAX = 512;


  function mergeUnitsPreserveFrames(localUnits, serverUnits) {
    const byId = new Map(localUnits.map(u => [u.id, u]));
    const merged = [];

    for (const su0 of (serverUnits || [])) {
      const existing = byId.get(su0.id);
      const su = {
        ...su0,
        anim: su0.anim || "idle",
        dir: String(su0.dir ?? "000").padStart(3,"0"),
        hp: (su0.hp ?? existing?.hp ?? UNIT_MAX_HEALTH),
        tx:   (su0.tx ?? su0.x),
        ty:   (su0.ty ?? su0.y),
      };

      let lu = byId.get(su.id);
  if (!lu) {
    lu = {
      ...su,
      frame: 0,
      attackFrame: 0,
      renderFrame: 0,
      renderAttackFrame: 0,
      lastX: su.x,
      lastY: su.y,
      selected: false,
      manualMove: false,

      // ✅ ADD THESE
      targetEnemy: null,
      attackCooldown: ATTACK_COOLDOWN, // allow immediate attack
      harvesting: null,
    };
  } else {
        // update authoritative fields
        lu.x = su.x; lu.y = su.y;
        lu.tx = su.tx; lu.ty = su.ty;
        lu.hp = su.hp;
        lu.dir = su.dir;

        if (lu.anim !== su.anim) {
          lu.anim = su.anim;
          lu.frame = 0;
          lu.attackFrame = 0;
          lu.renderFrame = 0;
          lu.renderAttackFrame = 0;
        }
      }
      merged.push(lu);
    }

    return merged;
  }



  /* ================= RESOURCES ================= */
  const RESOURCE_RADIUS = 40;
  const HARVEST_TIME = 10000; // ms

  const RESOURCE_STOP_RADIUS    = PLAYER_RADIUS + RESOURCE_RADIUS_COLLIDE + 1; // 36
  const RESOURCE_HARVEST_RADIUS = RESOURCE_STOP_RADIUS + 4;                    // 40



  resources = resources || [];          // {id, x, y}
  let harvesting = null;       // {resourceId, startTime}
  const resourceImg = new Image();
  resourceImg.src = "static/resource.png";
  const RES_W = 48;
  const RES_H = 48;

  resourceCount = resourceCount || 0;
  hoveredResource = hoveredResource || null;

  hoveredPlayerSid = hoveredPlayerSid || null;  

  function spawnResources(){
    const cols = 69;
    const rows = 53;
    const spacing = 180;
    let id = 0;

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(Math.random() < 0.6){
          resources.push({
            id: id++,
            x: (c - r) * spacing,
            y: (c + r) * spacing / 2
          });
        }
      }
    }
  }
  spawnResources();

  /* ================= COMBAT ================= */
  const ATTACK_RANGE = 80;
  const DPS = 10; // damage per second

  let targetPlayerSid = null;

  let playerHealth = {};
  const MAX_HEALTH = 100;

  /* ================= SOCKET STATE ================= */
  // Keep player positions/colors from state
  // Update remote units

  socket.on("state", (state) => {
    console.log("STATE: before merge myUnits", myUnits.length,
              "server me.units", state.players?.[mySid]?.units?.length);

    if (state.ground_items) groundItems = state.ground_items;

    // ✅ FIRST: sync my own units from server (adopt server ids)
    const me = state.players?.[mySid];
    if (me && Array.isArray(me.units)) {
      myUnits = mergeUnitsPreserveFrames(myUnits, me.units);
    }

    for (const sid in players){
            const first = players[sid].units[0];
    if (first) { players[sid].x = first.x; players[sid].y = first.y; }
    }


    // existing: remove players no longer on server
    for (const sid in players) {
      if (!state.players[sid] || !state.players[sid].units || state.players[sid].units.length === 0) {
        delete players[sid];
      }
    }

    // ✅ sync other players as you already do (but using same merge helper)
    for (const sid in state.players) {

      if (sid === mySid) continue;
      const sp = state.players[sid];

      if (!sp.units || sp.units.length === 0) {
        delete players[sid];
        continue;
      }

      if (!players[sid]) players[sid] = { x: 0, y: 0, color: "#fff", units: [] };

      players[sid].x = sp.x;
      players[sid].y = sp.y;
      players[sid].color = sp.color;

      players[sid].units = mergeUnitsPreserveFrames(players[sid].units || [], sp.units);
    }

    // buildings...
    buildings = state.buildings.map(sb => {
      const existing = buildings.find(b => b.x === sb.x && b.y === sb.y && b.owner === sb.owner);
      return {
        ...sb,
        selected: existing ? existing.selected : false,
        queue: existing ? existing.queue : []
      };
    });

    groundItems = state.ground_items || [];
  });

      

  socket.on("unit_hp_update", ({ sid, unitId, hp }) => {
      const list = sid === mySid ? myUnits : players[sid]?.units;
      if (!list) return;
      const u = list.find(u => u.id === unitId);
      if (!u) return;

      u.hp = hp;

      if (u.hp <= 0) {
          // remove locally
          const i = list.indexOf(u);
          if (i !== -1) list.splice(i, 1);
      }
  });

  socket.on("ground_items", (items) => {
    groundItems = items || [];
    // optional debug:
    // console.log("ground_items update", groundItems.length);
  });

  socket.on("update_units", ({ sid, units }) => {
    if (sid === mySid) return;

    // ✅ if server says this player has no units, remove them immediately
    if (!units || units.length === 0) {
      delete players[sid];
      return;
    }

    if (!players[sid]) players[sid] = { x:0, y:0, color:"#fff", units: [] };

    players[sid].units = mergeUnitsPreserveFrames(players[sid].units || [], units);

    // keep hover point synced
    const first = players[sid].units[0];
    if (first) {
      players[sid].x = first.x;
      players[sid].y = first.y;
    }
  });


  let selectedUnits = []; // Array of selected unit IDs
  let allUnits = {}; // sid -> units list (updated from server)

  // Function to render selected units in panel
  function renderUnitPanel() {
      const unitListDiv = document.getElementById("unit-list");
      unitListDiv.innerHTML = ""; // clear

      selectedUnits.forEach(uid => {
          let unit = findUnitById(uid);
          if (!unit) return;

          const unitDiv = document.createElement("div");
          unitDiv.textContent = `Unit ${unit.id.slice(0,4)}`; // show short id
          unitDiv.style.cursor = "pointer";
          unitDiv.style.marginBottom = "5px";
          unitDiv.style.padding = "2px 5px";
          unitDiv.style.border = "1px solid white";
          unitDiv.style.borderRadius = "4px";
          unitDiv.addEventListener("click", () => {
              renderUnitItems(unit);
          });
          unitListDiv.appendChild(unitDiv);
      });
  }

  function findUnitById(uid) {
      // Prefer local units (they definitely have items)
      const local = myUnits.find(u => u.id === uid);
      if (local) return local;

      for (let sid in allUnits) {
          const unit = (allUnits[sid] || []).find(u => u.id === uid);
          if (unit) return unit;
      }
      return null;
  }


  socket.on("unit_slots_update", ({ unitId, itemSlots }) => {
    const u = myUnits.find(x => x.id === unitId);
    if (!u) return;

    u.itemSlots = itemSlots;

    // refresh UI if currently showing this unit
    if (currentItemsUnitId === unitId) renderUnitItems(u);
  });


  let mapObjects = []; // persistent objects from server

  socket.on("map_objects", (objs) => {
    mapObjects = objs || [];
    // If entity inspector is open for an entity, refresh it immediately
    if (selectedEntityId) {
      const updated = mapObjects.find(x => x.id === selectedEntityId);
      if (updated && entityPanelEl && entityPanelEl.style.display === "block") {
        openEntityInspector(updated);
      }
    }
  });

  tile.onload = draw;
  </script>
  </body>
  </html>