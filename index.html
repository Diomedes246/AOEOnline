<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Isometric Infinite Terrain with Chat and Minimap and NPCs</title>
  <style>
    html, body {
      margin: 0; height: 100vh;
      background: #222;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: white;
    }
    #gameCanvas {
      border: 2px solid #333;
      background: #88ccee;
      display: block;
      position: absolute;
      left: 0; top: 0;
    }
    #tileSelectorContainer {
      position: fixed;
      right: 20px;
      bottom: 20px;
      max-height: 80vh;
      overflow-y: auto;
      border: 2px solid #333;
      background: #111;
      z-index: 10;
    }
    #tileSelector {
      display: block;
    }
    #chatContainer {
      position: fixed;
      left: 20px;
      bottom: 20px;
      width: 300px;
      max-height: 200px;
      background: rgba(0,0,0,0.7);
      border: 2px solid #333;
      display: flex;
      flex-direction: column;
      font-size: 14px;
      z-index: 20;
      color: white;
    }
    #chatMessages {
      flex-grow: 1;
      overflow-y: auto;
      padding: 8px;
      line-height: 1.3;
    }
    #chatInput {
      border: none;
      outline: none;
      padding: 6px 8px;
      font-size: 14px;
      background: #222;
      color: white;
    }
    #minimap {
      position: fixed;
      right: 20px;
      top: 20px;
      width: 200px;
      height: 200px;
      border: 2px solid #333;
      background: #111;
      z-index: 15;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="1000" height="800"></canvas>
<div id="tileSelectorContainer">
  <canvas id="tileSelector" width="256" height="3320"></canvas>
</div>

<div id="chatContainer">
  <div id="chatMessages"></div>
  <input id="chatInput" type="text" placeholder="Type message and press Enter" />
</div>

<canvas id="minimap" width="200" height="200"></canvas>

<script>
const TILE_WIDTH = 16;
const TILE_HEIGHT = 20;
const TILE_STEP_X = TILE_WIDTH / 2;
const TILE_STEP_Y = TILE_HEIGHT / 4;
const TILE_SHEET_WIDTH = 256;

// Tile indexes - adjust these to your tilesheet!
const TILE_GRASS = 535;          // grass base tiles variants
const TILE_GRASS_ALT1 = 536;
const TILE_GRASS_ALT2 = 537;
const TILE_FLOWERS = [600, 601, 602, 603];   // flower decorations
const TILE_BUSHES = [610, 611];               // bush decorations
const TILE_ROCKS = [620, 621];                // rock decorations
const TILE_WATER = 540;
const TILE_MOUNTAIN = 570;
const TILE_BUILDING = 580;
const TILE_ROAD = 550;
const CHARACTER_TILE = 1;
const CUBE_TILE = 1882;

const gameCanvas = document.getElementById('gameCanvas');
const ctx = gameCanvas.getContext('2d');

const selectorCanvas = document.getElementById('tileSelector');
const selectorCtx = selectorCanvas.getContext('2d');

const tileSheet = new Image();
tileSheet.src = 'Images/full_iso.png';

// Chat UI elements
const chatMessagesDiv = document.getElementById('chatMessages');
const chatInput = document.getElementById('chatInput');
const minimap = document.getElementById('minimap');
const minimapCtx = minimap.getContext('2d');

const playerId = 'p_' + Math.random().toString(36).substr(2, 9);

let playerName = localStorage.getItem('playerName');
if (!playerName) {
  playerName = prompt("Enter your player name:") || "Anon";
  localStorage.setItem('playerName', playerName);
}

let playerX = 0, playerY = 0;
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

const players = {};       // other players data: { x, y, name, chat: { text, timestamp } }
const placedTiles = new Map();
const buildingTiles = new Map();

let camX = playerX;
let camY = playerY;

let selectedTile = TILE_GRASS;
selectorCanvas.addEventListener('click', e => {
  const rect = selectorCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const col = Math.floor(x / TILE_WIDTH);
  const row = Math.floor(y / TILE_HEIGHT);
  const tilesPerRow = TILE_SHEET_WIDTH / TILE_WIDTH;
  selectedTile = row * tilesPerRow + col;
  console.log(`Selected tile: ${selectedTile}`);
});

gameCanvas.addEventListener('click', e => {
  const rect = gameCanvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const screenX = mouseX - gameCanvas.width / 2;
  const screenY = mouseY - gameCanvas.height / 4;

  const tileX = Math.floor((screenX / TILE_STEP_X + screenY / TILE_STEP_Y) / 2 + camX);
  const tileY = Math.floor((screenY / TILE_STEP_Y - screenX / TILE_STEP_X) / 2 + camY);

  const key = `${tileX},${tileY}`;

  // Update local map instantly
  placedTiles.set(key, selectedTile);

  // Send to server asynchronously
  fetch('https://jackpeterkettley.pythonanywhere.com/place_tile', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ x: tileX, y: tileY, tile: selectedTile })
  }).catch(console.error);
});

gameCanvas.addEventListener('contextmenu', e => {
  e.preventDefault();

  const rect = gameCanvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const screenX = mouseX - gameCanvas.width / 2;
  const screenY = mouseY - gameCanvas.height / 4;

  const tileX = Math.floor((screenX / TILE_STEP_X + screenY / TILE_STEP_Y) / 2 + camX);
  const tileY = Math.floor((screenY / TILE_STEP_Y - screenX / TILE_STEP_X) / 2 + camY);

  const key = `${tileX},${tileY}`;
  const currentHeight = buildingTiles.get(key) || 0;

  let newHeight;
  if (e.altKey) {
    newHeight = Math.max(0, currentHeight - 1);
  } else {
    newHeight = currentHeight + 1;
  }

  // Update local map instantly
  if (newHeight === 0) {
    buildingTiles.delete(key);
  } else {
    buildingTiles.set(key, newHeight);
  }

  // Send to server asynchronously
  fetch('https://jackpeterkettley.pythonanywhere.com/build_cube', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ x: tileX, y: tileY, height: newHeight })
  }).catch(console.error);
});



// Send player position and name to backend
async function sendPlayerPosition() {
  await fetch('https://jackpeterkettley.pythonanywhere.com/update_position', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ sid: playerId, x: playerX, y: playerY, name: playerName })
  });
}

// Fetch other players positions and names
async function fetchOtherPlayers() {
  const res = await fetch('https://jackpeterkettley.pythonanywhere.com/get_positions');
  const data = await res.json();
  for (const sid in data) {
    if (sid !== playerId) {
      const oldChat = players[sid]?.chat || null;
      players[sid] = data[sid];
      if (oldChat) players[sid].chat = oldChat;
    }
  }
}

// Fetch tiles and buildings
async function fetchTiles() {
  const res = await fetch('https://jackpeterkettley.pythonanywhere.com/get_tiles');
  const data = await res.json();
  for (const key in data) {
    placedTiles.set(key, data[key]);
  }
}

async function fetchBuildings() {
  const res = await fetch('https://jackpeterkettley.pythonanywhere.com/get_buildings');
  const data = await res.json();
  for (const key in data) {
    buildingTiles.set(key, data[key]);
  }
}

// Elevation and procedural terrain functions

function getElevation(x, y) {
  const freq = 0.05;
  const amp = 15;
  return Math.sin(x * freq) * Math.cos(y * freq) * amp;
}

function isRiver(x, y) {
  const riverCenter = Math.floor(50 * Math.sin(x * 0.1));
  return Math.abs(y - riverCenter) <= 3;
}

function isCityBlock(x, y) {
  const cityBlocks = [
    {xMin: 10, xMax: 30, yMin: 10, yMax: 30},
    {xMin: 40, xMax: 60, yMin: 20, yMax: 40},
    {xMin: -40, xMax: -20, yMin: -30, yMax: -10},
  ];
  return cityBlocks.some(b => x >= b.xMin && x <= b.xMax && y >= b.yMin && y <= b.yMax);
}

function isIsland(x, y) {
  const dx = x - 100;
  const dy = y - 100;
  return (dx*dx + dy*dy) < 100;
}

function pseudoRandom(seed) {
  return Math.abs(Math.sin(seed) * 10000) % 1;
}

function getTileAndDecoration(x, y) {
  const elevation = getElevation(x, y);
  const river = isRiver(x, y);
  const city = isCityBlock(x, y);
  const island = isIsland(x, y);

  if (river) return { base: TILE_WATER, decoration: null };
  if (elevation > 12) return { base: TILE_MOUNTAIN, decoration: null };
  if (city) {
    if (x % 5 === 0 || y % 5 === 0) return { base: TILE_ROAD, decoration: null };
    return { base: TILE_BUILDING, decoration: null };
  }
  if (island && !river) {
    const grassVariants = [TILE_GRASS, TILE_GRASS_ALT1, TILE_GRASS_ALT2];
    const idx = Math.floor(pseudoRandom(x * 374 + y * 927) * grassVariants.length);
    return { base: grassVariants[idx], decoration: null };
  }

  const grassVariants = [TILE_GRASS, TILE_GRASS_ALT1, TILE_GRASS_ALT2];
  const grassBaseIndex = grassVariants[Math.floor(pseudoRandom(x * 31 + y * 17) * grassVariants.length)];

  const decorationRoll = pseudoRandom(x * 17 + y * 37);
  let decoration = null;
  if (decorationRoll < 0.15) {
    if (decorationRoll < 0.05) {
      decoration = TILE_FLOWERS[Math.floor(pseudoRandom(x * 91 + y * 61) * TILE_FLOWERS.length)];
    } else if (decorationRoll < 0.1) {
      decoration = TILE_BUSHES[Math.floor(pseudoRandom(x * 71 + y * 41) * TILE_BUSHES.length)];
    } else {
      decoration = TILE_ROCKS[Math.floor(pseudoRandom(x * 53 + y * 29) * TILE_ROCKS.length)];
    }
  }

  return { base: grassBaseIndex, decoration };
}

function isoToScreen(tileX, tileY) {
  const baseX = (tileX - tileY) * TILE_STEP_X;
  const baseY = (tileX + tileY) * TILE_STEP_Y;
  const elevation = getElevation(tileX, tileY);
  return {
    x: baseX - (camX - camY) * TILE_STEP_X + gameCanvas.width / 2,
    y: baseY - elevation - (camX + camY) * TILE_STEP_Y + gameCanvas.height / 4
  };
}

function drawTile(tileIndex, dx, dy) {
  const tilesPerRow = TILE_SHEET_WIDTH / TILE_WIDTH;
  const sx = (tileIndex % tilesPerRow) * TILE_WIDTH;
  const sy = Math.floor(tileIndex / tilesPerRow) * TILE_HEIGHT;
  ctx.drawImage(tileSheet, sx, sy, TILE_WIDTH, TILE_HEIGHT, dx, dy, TILE_WIDTH, TILE_HEIGHT);
}

function drawPlayerName(name, x, y) {
  ctx.font = "12px Arial";
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = 3;
  ctx.textAlign = "center";
  ctx.strokeText(name, x + TILE_WIDTH / 2, y - TILE_HEIGHT);
  ctx.fillText(name, x + TILE_WIDTH / 2, y - TILE_HEIGHT);
}

function drawChatBubble(text, x, y) {
  if (!text) return;
  ctx.font = "12px Arial";
  const padding = 4;
  const maxWidth = 120;
  let lines = [];

  // Simple word wrap:
  const words = text.split(' ');
  let line = '';
  for (const word of words) {
    const testLine = line + word + ' ';
    const testWidth = ctx.measureText(testLine).width;
    if (testWidth > maxWidth && line.length > 0) {
      lines.push(line);
      line = word + ' ';
    } else {
      line = testLine;
    }
  }
  lines.push(line);

  const lineHeight = 14;
  const bubbleWidth = maxWidth + padding*2;
  const bubbleHeight = lines.length * lineHeight + padding*2;

  // Bubble background with rounded corners
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 1;
  const radius = 6;

  ctx.beginPath();
  ctx.moveTo(x, y - bubbleHeight);
  ctx.lineTo(x + bubbleWidth, y - bubbleHeight);
  ctx.quadraticCurveTo(x + bubbleWidth + radius, y - bubbleHeight, x + bubbleWidth + radius, y - bubbleHeight + radius);
  ctx.lineTo(x + bubbleWidth + radius, y);
  ctx.quadraticCurveTo(x + bubbleWidth + radius, y + radius, x + bubbleWidth, y + radius);
  ctx.lineTo(x, y + radius);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Draw text lines
  ctx.fillStyle = 'white';
  ctx.textAlign = 'left';
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], x + padding, y - bubbleHeight + padding + (i + 1) * lineHeight - 4);
  }
}

function screenToIsoExact(screenX, screenY) {
  const dx = screenX - gameCanvas.width / 2;
  const dy = screenY - gameCanvas.height / 4;
  return {
    tileX: (dx / TILE_STEP_X + dy / TILE_STEP_Y) / 2 + camX,
    tileY: (dy / TILE_STEP_Y - dx / TILE_STEP_X) / 2 + camY
  };
}

function drawMinimap() {
  const mapSize = 200;
  const scale = 3; // tiles per pixel approx

  minimapCtx.clearRect(0, 0, mapSize, mapSize);

  // Background
  minimapCtx.fillStyle = "#224422";
  minimapCtx.fillRect(0, 0, mapSize, mapSize);

  // Draw players as dots
  for (const sid in players) {
    const p = players[sid];
    // Translate player coords relative to current player
    const dx = (p.x - playerX);
    const dy = (p.y - playerY);

    const px = mapSize/2 + dx * scale;
    const py = mapSize/2 + dy * scale;

    if (px < 0 || px > mapSize || py < 0 || py > mapSize) continue;

    minimapCtx.fillStyle = (sid === playerId) ? "yellow" : "red";
    minimapCtx.beginPath();
    minimapCtx.arc(px, py, 4, 0, 2*Math.PI);
    minimapCtx.fill();
  }

  // Draw NPCs on minimap (blue dots)
  NPCs.forEach(npc => {
    const dx = (npc.x - playerX);
    const dy = (npc.y - playerY);
    const px = mapSize/2 + dx * scale;
    const py = mapSize/2 + dy * scale;
    if (px < 0 || px > mapSize || py < 0 || py > mapSize) return;
    minimapCtx.fillStyle = "blue";
    minimapCtx.beginPath();
    minimapCtx.arc(px, py, 3, 0, 2*Math.PI);
    minimapCtx.fill();
  });

  // Draw viewport rectangle
  const viewWidthTiles = gameCanvas.width / TILE_WIDTH;
  const viewHeightTiles = gameCanvas.height / TILE_HEIGHT;

  minimapCtx.strokeStyle = "white";
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(
    mapSize/2 - viewWidthTiles/2 * scale,
    mapSize/2 - viewHeightTiles/2 * scale,
    viewWidthTiles * scale,
    viewHeightTiles * scale
  );
}

// Chat message sending logic
chatInput.addEventListener('keydown', async e => {
  if (e.key === 'Enter' && chatInput.value.trim().length > 0) {
    const message = chatInput.value.trim();

    try {
      await fetch('https://jackpeterkettley.pythonanywhere.com/send_chat', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ sid: playerId, text: message })
      });
      chatInput.value = '';
    } catch (err) {
      console.error('Failed to send chat message:', err);
    }
  }
});

// Receive chat messages from backend
async function fetchChats() {
  const res = await fetch('https://jackpeterkettley.pythonanywhere.com/get_chats');
  const data = await res.json();
  chatMessagesDiv.innerHTML = '';  // clear

  for (const chat of data) {
    const msg = document.createElement('div');
    msg.textContent = `${chat.name}: ${chat.text}`;
    chatMessagesDiv.appendChild(msg);
  }
  chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
}

// --- NPC implementation ---
const NPC_COUNT = 5;
const NPCs = [];

// Initialize NPCs near player start
for (let i = 0; i < NPC_COUNT; i++) {
  NPCs.push({
    id: 'npc_' + i,
    x: playerX + (Math.random() - 0.5) * 20,
    y: playerY + (Math.random() - 0.5) * 20,
    dirX: 0,
    dirY: 0,
    moveCooldown: 0
  });
}

function updateNPCs(deltaTime) {
  NPCs.forEach(npc => {
    npc.moveCooldown -= deltaTime;
    if (npc.moveCooldown <= 0) {
      const angle = Math.random() * 2 * Math.PI;
      npc.dirX = Math.cos(angle);
      npc.dirY = Math.sin(angle);
      npc.moveCooldown = 1000 + Math.random() * 2000;
    }

    const speed = 0.002;
    npc.x += npc.dirX * speed * deltaTime;
    npc.y += npc.dirY * speed * deltaTime;

    const distX = npc.x - playerX;
    const distY = npc.y - playerY;
    if (Math.abs(distX) > 30) npc.dirX = -npc.dirX;
    if (Math.abs(distY) > 30) npc.dirY = -npc.dirY;
  });
}

let hoverBuildTile = { x: null, y: null, height: 0 };

gameCanvas.addEventListener('mousemove', e => {
  const rect = gameCanvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const screenX = mouseX - gameCanvas.width / 2;
  const screenY = mouseY - gameCanvas.height / 4;

  const tileX = Math.floor((screenX / TILE_STEP_X + screenY / TILE_STEP_Y) / 2 + camX);
  const tileY = Math.floor((screenY / TILE_STEP_Y - screenX / TILE_STEP_X) / 2 + camY);

  const key = `${tileX},${tileY}`;
  const currentHeight = buildingTiles.get(key) || 0;

  hoverBuildTile.x = tileX;
  hoverBuildTile.y = tileY;
  hoverBuildTile.height = e.altKey ? Math.max(0, currentHeight - 1) : currentHeight + 1;
});




let lastTime = performance.now();

function gameLoop(time = performance.now()) {
  const deltaTime = time - lastTime;
  lastTime = time;

  const playerSpeed = 0.01;
  if (keys['ArrowUp'])    { playerX -= playerSpeed * deltaTime; playerY -= playerSpeed * deltaTime; }
  if (keys['ArrowDown'])  { playerX += playerSpeed * deltaTime; playerY += playerSpeed * deltaTime; }
  if (keys['ArrowLeft'])  { playerX -= playerSpeed * deltaTime; playerY += playerSpeed * deltaTime; }
  if (keys['ArrowRight']) { playerX += playerSpeed * deltaTime; playerY -= playerSpeed * deltaTime; }

  camX = playerX;
  camY = playerY;

  updateNPCs(deltaTime);

  ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

  const corners = [
    screenToIsoExact(0, 0),
    screenToIsoExact(gameCanvas.width, 0),
    screenToIsoExact(0, gameCanvas.height),
    screenToIsoExact(gameCanvas.width, gameCanvas.height)
  ];
  const minX = Math.floor(Math.min(...corners.map(c => c.tileX))) - 3;
  const maxX = Math.ceil(Math.max(...corners.map(c => c.tileX))) + 3;
  const minY = Math.floor(Math.min(...corners.map(c => c.tileY))) - 3;
  const maxY = Math.ceil(Math.max(...corners.map(c => c.tileY))) + 3;

  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      const { x: sx, y: sy } = isoToScreen(x, y);
      const key = `${x},${y}`;

      let baseTile, decorationTile;
      if (placedTiles.has(key)) {
        baseTile = placedTiles.get(key);
        decorationTile = null;
      } else {
        const tileInfo = getTileAndDecoration(x, y);
        baseTile = tileInfo.base;
        decorationTile = tileInfo.decoration;
      }

      drawTile(baseTile, sx, sy);

      if (decorationTile !== null) {
        drawTile(decorationTile, sx, sy - TILE_STEP_Y);
      }

      const bHeight = buildingTiles.get(key) || 0;
      for (let z = 0; z < bHeight; z++) {
        drawTile(CUBE_TILE, sx, sy - z * TILE_STEP_Y * 2);
      }
    }
  }

  // âœ… --- Hover build preview ---
  if (hoverBuildTile.x !== null && hoverBuildTile.height > 0) {
    const { x: sx, y: sy } = isoToScreen(hoverBuildTile.x, hoverBuildTile.y);
    ctx.globalAlpha = 0.5; // Ghost look
    for (let z = 0; z < hoverBuildTile.height; z++) {
      drawTile(CUBE_TILE, sx, sy - z * TILE_STEP_Y * 2);
    }
    ctx.globalAlpha = 1.0; // Reset
  }

  // Draw NPCs
  NPCs.forEach(npc => {
    const screenPos = isoToScreen(npc.x, npc.y);
    drawTile(2, screenPos.x, screenPos.y - (TILE_HEIGHT - TILE_STEP_Y));  // NPC tile, change '2' if you want
    drawPlayerName("NPC", screenPos.x, screenPos.y - (TILE_HEIGHT - TILE_STEP_Y));
  });

  // Draw other players & chat bubbles
  const now = Date.now();
  for (const sid in players) {
    if (sid === playerId) continue;
    const p = players[sid];
    const screenPos = isoToScreen(p.x, p.y);
    drawTile(CHARACTER_TILE, screenPos.x, screenPos.y - (TILE_HEIGHT - TILE_STEP_Y));
    if (p.name) {
      drawPlayerName(p.name, screenPos.x, screenPos.y - (TILE_HEIGHT - TILE_STEP_Y));
    }
    if (p.chat && now - p.chat.timestamp < 5000) {
      drawChatBubble(p.chat.text, screenPos.x + TILE_WIDTH, screenPos.y - TILE_HEIGHT * 2);
    }
  }

  // Draw local player and chat bubble
  const playerScreen = isoToScreen(playerX, playerY);
  drawTile(CHARACTER_TILE, playerScreen.x, playerScreen.y - (TILE_HEIGHT - TILE_STEP_Y));
  drawPlayerName(playerName, playerScreen.x, playerScreen.y - (TILE_HEIGHT - TILE_STEP_Y));
  if (players[playerId]?.chat && now - players[playerId].chat.timestamp < 5000) {
    drawChatBubble(players[playerId].chat.text, playerScreen.x + TILE_WIDTH, playerScreen.y - TILE_HEIGHT * 2);
  }

  drawMinimap();

  requestAnimationFrame(gameLoop);
}

// --- Periodic updates ---
setInterval(() => {
  sendPlayerPosition();
  fetchOtherPlayers();
  fetchTiles();
  fetchBuildings();
  fetchChats();
}, 1000); // faster sync for smoothness

// --- Tile selector drawing ---
tileSheet.onload = () => {
  for (let i = 0; i < 3320 / TILE_HEIGHT; i++) {
    for (let j = 0; j < TILE_SHEET_WIDTH / TILE_WIDTH; j++) {
      const tileIndex = i * (TILE_SHEET_WIDTH / TILE_WIDTH) + j;
      selectorCtx.drawImage(tileSheet, j * TILE_WIDTH, i * TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT,
        j * TILE_WIDTH, i * TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
    }
  }
  requestAnimationFrame(gameLoop);
};
</script>
</body>
</html>
