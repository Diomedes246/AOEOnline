<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Isometric Multiplayer RTS</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:black; }
canvas { display:block; }
#hud {
  position:fixed;
  top:10px; left:10px;
  color:white;
  font-family:monospace;
  background:rgba(0,0,0,0.5);
  padding:6px;
}
#panel {
  position:fixed;
  bottom:20px;
  left:20px;
  width:220px;
  height:120px;
  background:rgba(30,30,30,0.85);
  border:2px solid #888;
  padding:10px;
  color:white;
  font-family:monospace;
  display:none;
}

#buildBtn {
  width:100%;
  height:40px;
  margin-top:10px;
  background:#444;
  color:white;
  border:1px solid #aaa;
  cursor:pointer;
}
#buildBtn:hover { background:#666; }
#buildBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
</style>
</head>

<body>
<canvas id="game"></canvas>
<div id="hud"></div>

<div id="panel">
  <div>Unit Selected</div>
  <button id="buildBtn">Place Building</button>
</div>

<div id="buildingPanel" style="display:none; position:fixed; bottom:20px; left:20px; width:220px; height:120px; background:rgba(30,30,30,0.85); border:2px solid #888; padding:10px; color:white; font-family:monospace;">
  <div>Building Selected</div>
  <button id="createUnitBtn">Create Unit</button>
</div>

<div id="unit-panel" style="position:fixed; right:10px; top:10px; width:200px; background:rgba(0,0,0,0.7); color:white; padding:10px; border-radius:8px;">
    <h3>Selected Units</h3>
    <div id="unit-list"></div>
    <div id="unit-items" style="margin-top:10px;">
        <h4>Unit Items</h4>
        <ul id="items-list"></ul>
    </div>
</div>


<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");
const panel = document.getElementById("panel");
const buildBtn = document.getElementById("buildBtn");
const socket = io();

let mySid = null;
socket.on("connect", ()=> mySid = socket.id);

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

let DEBUG_COLLISIONS = true; // toggle on/off

function drawCircleDebug(x, y, r, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.stroke();
}

function drawRectDebug(x, y, w, h, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
}


/* ================= CAMERA ================= */
let camera = {x:0,y:0};
const camSpeed = 12;
const keys = {};
document.addEventListener("keydown", e=>keys[e.key]=true);
document.addEventListener("keyup", e=>keys[e.key]=false);


/* ================= PLAYER SPRITES ================= */

const SPRITE_W = 256;
const SPRITE_H = 256;
const DIRECTIONS = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337];
const IDLE_FRAMES = 24;
const WALK_FRAMES = 24;
const ANIM_SPEED = 0.3;


const UNIT_RADIUS = 18;
const PLAYER_RADIUS = 20;
const TREE_RADIUS = 140;
const RESOURCE_RADIUS_COLLIDE = 28;

// Buildings use rectangle collision
const BUILD_COLLISION_PADDING = -50;


const UNIT_ATTACK_RANGE = PLAYER_RADIUS + UNIT_RADIUS + 10; // 10 extra for buffer
const UNIT_ATTACK_DPS = 30; // damage per second
const ATTACK_COOLDOWN = 1000 / 60; // 1 tick per frame (60fps)
const UNIT_MAX_HEALTH = 100;
const ATTACK_ANIM_FRAMES = 24;


let groundItems = []; // {id, name, x, y}

const itemIcons = {
  sword: new Image(),
  shield: new Image()
};
itemIcons.sword.src = "static/items/sword.png";   // make these files
itemIcons.shield.src = "static/items/shield.png"; // or draw text fallback
const GROUND_ITEM_SIZE = 32;
const PICKUP_RADIUS = 26;

const PICKUP_DISTANCE = 120; // how close unit must be to pick up from ground
let currentItemsUnitId = null; // which unit's equipment UI is currently showing


function unitCanPickup(unit, groundItem) {
  return Math.hypot(unit.x - groundItem.x, unit.y - groundItem.y) <= PICKUP_DISTANCE;
}

let hoveredGroundItem = null;

let draggingPickup = null; // { groundItemId, unitId }
let dragMouse = { x: 0, y: 0 };

function findSlotElementAtScreen(x, y) {
  const el = document.elementFromPoint(x, y);
  if (!el) return null;
  return el.closest && el.closest("#items-list li");
}

function getFirstSelectedUnit() {
  return myUnits.find(u => u.selected) || null;
}
function onGlobalDragMove(e) {
  // keep mouse updated even over UI
  dragMouse.x = e.clientX;
  dragMouse.y = e.clientY;

  // optional: block text selection while dragging
  e.preventDefault();
}

function onGlobalDragEnd(e) {
  // stop capturing
  window.removeEventListener("mousemove", onGlobalDragMove, true);
  window.removeEventListener("mouseup", onGlobalDragEnd, true);

  if (!draggingPickup) return;

  const gi = groundItems.find(x => x.id === draggingPickup.groundItemId);
  const picker = myUnits.find(u => u.id === draggingPickup.unitId);
  draggingPickup = null;

  if (!gi || !picker) return;

  // must still be in range
  if (!unitCanPickup(picker, gi)) return;

  // must drop on a slot
  const slotEl = findSlotElementAtScreen(e.clientX, e.clientY);
  if (!slotEl) return;

  const slotIndex = parseInt(slotEl.dataset.slotIndex, 10);
  const unitId = slotEl.dataset.unitId;

  const targetUnit = myUnits.find(u => u.id === unitId);
  if (!targetUnit) return;

  if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null];
  if (targetUnit.itemSlots[slotIndex]) return; // must be empty

  // equip + remove from ground
  targetUnit.itemSlots[slotIndex] = { id: crypto.randomUUID(), name: gi.name };
  groundItems = groundItems.filter(x => x.id !== gi.id);

  renderUnitItems(targetUnit);
}


function renderUnitItems(unit) {
  currentItemsUnitId = unit.id;

  const itemsList = document.getElementById("items-list");
  itemsList.innerHTML = "";

  if (!unit.itemSlots) unit.itemSlots = [null, null];

  for (let i = 0; i < 2; i++) {
    const slot = unit.itemSlots[i];

    const li = document.createElement("li");
    li.style.display = "flex";
    li.style.alignItems = "center";
    li.style.justifyContent = "space-between";
    li.style.border = "1px solid #777";
    li.style.borderRadius = "6px";
    li.style.padding = "6px";
    li.style.marginBottom = "6px";
    li.style.background = "rgba(255,255,255,0.05)";

    li.dataset.slotIndex = String(i);
    li.dataset.unitId = unit.id;

    const left = document.createElement("div");
    left.textContent = `Slot ${i + 1}: ${slot ? slot.name : "(empty)"}`;
    li.appendChild(left);

    // Allow dropping from ground -> slot OR slot -> slot
    li.addEventListener("dragover", (e) => {
      e.preventDefault();
      li.style.outline = "2px dashed #fff";
    });
    li.addEventListener("dragleave", () => {
      li.style.outline = "";
    });

    li.addEventListener("drop", (e) => {
      e.preventDefault();
      li.style.outline = "";

      const payloadStr = e.dataTransfer.getData("application/json");
      if (!payloadStr) return;

      let payload;
      try { payload = JSON.parse(payloadStr); } catch { return; }

      const targetUnit = myUnits.find(u => u.id === unit.id);
      if (!targetUnit) return;
      if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null];

      const slotIndex = i;

      // If dropping a ground item into this slot:
      if (payload.type === "ground_item") {
        const gi = groundItems.find(x => x.id === payload.groundItemId);
        if (!gi) return;

        // Must be close enough to pick up
        if (!unitCanPickup(targetUnit, gi)) return;

        // Slot must be empty
        if (targetUnit.itemSlots[slotIndex]) return;

        targetUnit.itemSlots[slotIndex] = { id: crypto.randomUUID(), name: gi.name };
        groundItems = groundItems.filter(x => x.id !== gi.id);

        renderUnitItems(targetUnit);
        return;
      }

      // If dropping a unit item (slot -> slot) (optional nice feature):
      if (payload.type === "unit_item") {
        const fromUnit = myUnits.find(u => u.id === payload.unitId);
        if (!fromUnit || !fromUnit.itemSlots) return;

        const fromSlot = payload.slotIndex;
        const moving = fromUnit.itemSlots[fromSlot];
        if (!moving) return;

        // If target slot occupied, swap
        const temp = targetUnit.itemSlots[slotIndex];
        targetUnit.itemSlots[slotIndex] = moving;
        fromUnit.itemSlots[fromSlot] = temp || null;

        renderUnitItems(targetUnit);
        return;
      }
    });

    // If slot has item: make it draggable out
    if (slot) {
      const chip = document.createElement("div");
      chip.textContent = "drag";
      chip.style.padding = "3px 8px";
      chip.style.border = "1px solid #aaa";
      chip.style.borderRadius = "6px";
      chip.style.cursor = "grab";
      chip.style.userSelect = "none";
      chip.style.background = "rgba(0,0,0,0.3)";
      chip.draggable = true;

      chip.addEventListener("dragstart", (e) => {
        const payload = {
          type: "unit_item",
          unitId: unit.id,
          slotIndex: i,
          item: slot
        };
        e.dataTransfer.setData("application/json", JSON.stringify(payload));
        e.dataTransfer.effectAllowed = "move";
      });

      li.appendChild(chip);
    }

    itemsList.appendChild(li);
  }
}




canvas.addEventListener("dragover", (e) => {
  e.preventDefault(); // allow drop
});

canvas.addEventListener("drop", (e) => {
  e.preventDefault();

  let payloadStr = e.dataTransfer.getData("application/json");
  if (!payloadStr) return;

  let payload;
  try { payload = JSON.parse(payloadStr); }
  catch { return; }

  if (payload.type !== "unit_item") return;
   // Allow moving a ground item around by dragging on canvas (optional)
  if (payload.type === "ground_item") {
    const gi = groundItems.find(x => x.id === payload.groundItemId);
    if (!gi) return;
    gi.x = wx;
    gi.y = wy;
    return;
  }

  const { unitId, slotIndex, item } = payload;

  // Convert screen -> world
  const wx = camera.x + e.clientX - canvas.width / 2;
  const wy = camera.y + e.clientY - canvas.height / 2;

  // Find local unit (only allow dragging from your own units)
  const u = myUnits.find(x => x.id === unitId);
  if (!u || !u.itemSlots) return;

  // Verify still in that slot
  const slot = u.itemSlots[slotIndex];
  if (!slot || slot.id !== item.id) return;

  // Remove from unit slot
  u.itemSlots[slotIndex] = null;

  // Spawn ground item
  groundItems.push({
    id: crypto.randomUUID(),
    name: item.name,
    x: wx,
    y: wy
  });

  // Refresh panel if this unit is the currently displayed one
  renderUnitItems(u);

  // OPTIONAL: emit to server so others see it
  // socket.emit("drop_item", { item: { id: ..., name: item.name, x: wx, y: wy }, fromUnitId: unitId, slotIndex });
});





const playerSprites = {
  idle: {},
  walk: {},
  idleshadow:{},
  walkshadow:{},
};

function pad(num, length=3) { return num.toString().padStart(length, "0"); }
function padFrame(num, length=4) { return num.toString().padStart(length, "0"); }



for (const deg of DIRECTIONS) {
  const d = pad(deg);

  playerSprites.idle[d] = [];
  playerSprites.walk[d] = [];
  playerSprites.idleshadow[d] = [];
  playerSprites.walkshadow[d] = [];

  // Idle frames
  for (let i = 1; i <= IDLE_FRAMES; i++) {
    const img = new Image();
    img.src = `static/Idle/Body/${d}/Idle_Body_${d}_${padFrame(i)}.png`;
    playerSprites.idle[d].push(img);
    const imgshadow = new Image();
    imgshadow.src = `static/Idle/Shadow/${d}/Idle_Shadow_${d}_${padFrame(i)}.png`;
    playerSprites.idleshadow[d].push(imgshadow);
  }

  // Walk frames
  for (let i = 1; i <= WALK_FRAMES; i++) {
    const img = new Image();
    img.src = `static/Run/Body/${d}/Run_Body_${d}_${padFrame(i)}.png`;
    playerSprites.walk[d].push(img);
    const imgshadow = new Image();
    imgshadow.src = `static/Run/Shadow/${d}/Run_Shadow_${d}_${padFrame(i)}.png`;
    playerSprites.walkshadow[d].push(imgshadow);
  }
}

// Inside playerSprites
playerSprites.attack = {};
playerSprites.attackshadow = {};
for(const deg of DIRECTIONS){
    const d = pad(deg);
    playerSprites.attack[d] = [];
    playerSprites.attackshadow[d] = [];
    for(let i=1;i<=ATTACK_ANIM_FRAMES;i++){
        const img = new Image();
        img.src = `static/Attack/Body/${d}/Attack1_Body_${d}_${padFrame(i)}.png`;
        playerSprites.attack[d].push(img);

        const imgShadow = new Image();
        imgShadow.src = `static/Attack/Shadow/${d}/Attack1_Shadow_${d}_${padFrame(i)}.png`;
        playerSprites.attackshadow[d].push(imgShadow);
    }
}





function getDirKey(dx, dy) {
    // invert dy because screen Y increases down but 000 is north
    const angle = ((Math.atan2(dy, dx) * 180 / Math.PI + 90) % 360);

    const dirs = [0,22,45,67,90,112,135,157,180,202,225,247,270,292,315,337];
    let closest = dirs[0];
    let minDiff = 360;

    for(const d of dirs){
        let diff = Math.abs(d - angle);
        diff = Math.min(diff, 360 - diff);
        if(diff < minDiff){
            minDiff = diff;
            closest = d;
        }
    }

    return closest.toString().padStart(3,"0");
}


function getUnitTargetOffset(idx, total) {
    // Spread in a circle around target
    const angle = (idx / total) * Math.PI * 2; // even spacing
    const radius = total*10; // distance from center
    return {
        dx: Math.cos(angle) * radius,
        dy: Math.sin(angle) * radius
    };
}


/* ================= LOCAL UNITS ================= */
let myUnits = [
  {
    id: crypto.randomUUID(),   // ✅ ADD THIS
    x: 0, y: 0,
    tx: 0, ty: 0,
    selected: false,
    targetResource: null,
    anim: "idle",
    frame: 0,
    dir: "000",
    lastX: 0,
    lastY: 0,
    hp: UNIT_MAX_HEALTH,
    attackCooldown: 0,
    attackFrame: 0,
    manualMove: false,
    itemSlots: [
  { id: crypto.randomUUID(), name: "sword" },
  { id: crypto.randomUUID(), name: "shield" }
]
  }
];


for(const u of myUnits){
    u.hp = 100;           // max health
    u.targetEnemy = null;  // {sid, unitIndex} or null
    u.attackCooldown = 0;  // ms cooldown for attack ticks
    u.attackFrame = 0;     // animation frame 0-23
    u.manualMove = false; // true if user right-clicked to move
}



function findNearestEnemy(u) {
    let nearest = null;
    let nearestDist = Infinity;

    // Check other players' units
    for(const sid in players){
        if(sid === mySid) continue;
        const p = players[sid];
        p.units.forEach((eu, idx) => {
            if(eu.hp <= 0) return;
            const dist = Math.hypot(u.x - eu.x, u.y - eu.y);
            if(dist < nearestDist){
                nearestDist = dist;
                nearest = {
    sid,
    unitId: eu.id,
    x: eu.x,
    y: eu.y
};

            }
        });
    }

    return nearest;
}


function getDirection(dx, dy) {
  const angle = Math.atan2(dy, dx); // -PI to PI
  let dir = Math.round((angle / (2 * Math.PI)) * DIRECTIONS);
  if (dir < 0) dir += DIRECTIONS;
  return dir % DIRECTIONS;
}

let players = {};
let buildings = []; // list of {x, y, owner}







/* ================= TILE ================= */
const tile = new Image();
tile.src = "static/grassbackground.png";
const TILE_W = 5178;
const TILE_H = 3009;
const HALF_W = TILE_W/2.1;
const HALF_H = TILE_H/2.1;


const treeImg = new Image();
treeImg.src = "static/tree.png";

// Adjust to your sprite size
const TREE_W = 250;
const TREE_H = 250;

// Trees will come from server
let trees = []; // [{x,y},...]

socket.on("server_trees", serverTrees => {
    trees = serverTrees;
});



/* ================= RESOURCES ================= */
const RESOURCE_RADIUS = 40;
const HARVEST_TIME = 10000; // ms

let resources = [];          // {id, x, y}
let harvesting = null;       // {resourceId, startTime}
const resourceImg = new Image();
resourceImg.src = "static/resource.png";
const RES_W = 48;
const RES_H = 48;

let resourceCount = 0;
let hoveredResource = null;

let hoveredPlayerSid = null;  

function spawnResources(){
  const cols = 69;
  const rows = 53;
  const spacing = 180;
  let id = 0;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(Math.random() < 0.035){
        resources.push({
          id: id++,
          x: (c - r) * spacing,
          y: (c + r) * spacing / 2
        });
      }
    }
  }
}
spawnResources();

function resolveCircleCircle(a, ar, b, br) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.hypot(dx, dy);
    const minDist = ar + br;

    // ---------- DEBUG DRAW ----------
    if (DEBUG_COLLISIONS) {
        const ax = canvas.width/2 + a.x - camera.x;
        const ay = canvas.height/2 + a.y - camera.y;
        const bx = canvas.width/2 + b.x - camera.x;
        const by = canvas.height/2 + b.y - camera.y;

        ctx.strokeStyle = "rgba(0,255,255,0.4)";
        ctx.beginPath();
        ctx.arc(ax, ay, ar, 0, Math.PI*2);
        ctx.stroke();

        ctx.strokeStyle = "rgba(255,0,0,0.4)";
        ctx.beginPath();
        ctx.arc(bx, by, br, 0, Math.PI*2);
        ctx.stroke();
    }
    // ------------------------------

    if (dist === 0 || dist >= minDist) return;

    const overlap = minDist - dist;
    const nx = dx / dist;
    const ny = dy / dist;

    // Apply push
    a.x += nx * overlap;
    a.y += ny * overlap;

    // ---------- DEBUG PENETRATION ----------
    if (DEBUG_COLLISIONS) {
        const ax = canvas.width/2 + a.x - camera.x;
        const ay = canvas.height/2 + a.y - camera.y;

        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + nx * overlap, ay + ny * overlap);
        ctx.stroke();
    }
}

function resolveCircleRect(unit, radius, rect) {
    const left   = rect.x - BUILD_W/2 - BUILD_COLLISION_PADDING;
    const right  = rect.x + BUILD_W/2 + BUILD_COLLISION_PADDING;
    const top    = rect.y - BUILD_H/2 - BUILD_COLLISION_PADDING;
    const bottom = rect.y + BUILD_H/2 + BUILD_COLLISION_PADDING;

    const closestX = Math.max(left, Math.min(unit.x, right));
    const closestY = Math.max(top, Math.min(unit.y, bottom));

    const dx = unit.x - closestX;
    const dy = unit.y - closestY;
    const dist = Math.hypot(dx, dy);

    // ---------- DEBUG DRAW ----------
    if (DEBUG_COLLISIONS) {
        const ux = canvas.width/2 + unit.x - camera.x;
        const uy = canvas.height/2 + unit.y - camera.y;

        ctx.strokeStyle = "rgba(255,0,0,0.4)";
        ctx.strokeRect(canvas.width/2 + left - camera.x, canvas.height/2 + top - camera.y, right-left, bottom-top);

        ctx.strokeStyle = "rgba(0,255,255,0.4)";
        ctx.beginPath();
        ctx.arc(ux, uy, radius, 0, Math.PI*2);
        ctx.stroke();
    }
    // ------------------------------

    if (dist === 0 || dist >= radius) return;

    const overlap = radius - dist;
    const nx = dx / dist;
    const ny = dy / dist;

    // Apply push
    unit.x += nx * overlap;
    unit.y += ny * overlap;

    // ---------- DEBUG PENETRATION ----------
    if (DEBUG_COLLISIONS) {
        const ux = canvas.width/2 + unit.x - camera.x;
        const uy = canvas.height/2 + unit.y - camera.y;

        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(ux, uy);
        ctx.lineTo(ux + nx * overlap, uy + ny * overlap);
        ctx.stroke();
    }
}

function applyCollisions(u) {
    // Trees
    for (const t of trees) resolveCircleCircle(u, PLAYER_RADIUS, {x: t.x, y: t.y-150}, TREE_RADIUS);

    // Resources
    for (const r of resources) resolveCircleCircle(u, PLAYER_RADIUS, {x: r.x, y: r.y}, RESOURCE_RADIUS_COLLIDE);

    // Buildings
    for (const b of buildings) resolveCircleRect(u, PLAYER_RADIUS, b);

    // Other local units
    for (const other of myUnits) {
        if (other === u) continue;
        resolveCircleCircle(u, UNIT_RADIUS, other, UNIT_RADIUS);
    }

    // Other players' units
    for (const sid in players) {
        if (sid === mySid) continue;
        for (const opUnit of players[sid].units) {
            resolveCircleCircle(u, PLAYER_RADIUS, opUnit, UNIT_RADIUS);
        }
    }

    // Optional: other players as a single "main unit" collision
    // for (const sid in players) {
    //     if (sid === mySid) continue;
    //     const op = players[sid];
    //     resolveCircleCircle(u, PLAYER_RADIUS, {x: op.x, y: op.y}, PLAYER_RADIUS);
    // }
}



/* ================= RTS INPUT ================= */
let selecting=false;
let selectStart={x:0,y:0};
let mouse={x:0,y:0};
let buildMode=false;
let localBuildingPlaced=false;

canvas.addEventListener("mousemove", e=>{
  mouse.x = e.clientX;
  mouse.y = e.clientY;

  const wx = camera.x + mouse.x - canvas.width/2;
  const wy = camera.y + mouse.y - canvas.height/2;

  hoveredResource = null;
  hoveredPlayerSid = null;

    // Ground item hover (priority 0)
  hoveredGroundItem = null;
  for (const it of groundItems) {
    if (Math.hypot(it.x - wx, it.y - wy) < 18) {
      hoveredGroundItem = it;
      canvas.style.cursor = "grab";
      break;
    }
  }
 if (hoveredGroundItem && !draggingPickup) return;


  // Resource hover (priority 1)
  for(const r of resources){
    if(Math.hypot(r.x-wx, r.y-wy) < RESOURCE_RADIUS){
      hoveredResource = r;
      canvas.style.cursor = "pointer";
      return;
    }
  }

  // Player hover (priority 2)
  for(const sid in players){
    if(sid === mySid) continue;
    const p = players[sid];
    if(Math.hypot(p.x-wx, p.y-wy) < 20){
      hoveredPlayerSid = sid;
      canvas.style.cursor = "crosshair";
      return;
    }
  }

  canvas.style.cursor = "default";
});


// { groundItemId, offsetX, offsetY, unitId }

function getFirstSelectedUnit() {
  return myUnits.find(u => u.selected) || null;
}

function findSlotElementAtScreen(x, y) {
  const el = document.elementFromPoint(x, y);
  if (!el) return null;
  // climb up to the LI
  return el.closest && el.closest("#items-list li");
}



function updateSelectedUnits() {
    // Build the lookup table from current live data
    allUnits[mySid] = myUnits;
    for (const sid in players) {
        allUnits[sid] = players[sid].units || [];
    }

    selectedUnits = myUnits.filter(u => u.selected).map(u => u.id);

    renderUnitPanel();

    // If nothing selected, clear items UI
    if (selectedUnits.length === 0) {
        document.getElementById("items-list").innerHTML = "";
        return;
    }

    // Auto-show items for first selected unit (local units have items)
    const unit = findUnitById(selectedUnits[0]);
    if (unit) renderUnitItems(unit);
}




canvas.addEventListener("mousedown", e => {
  const wx = camera.x + mouse.x - canvas.width / 2;
  const wy = camera.y + mouse.y - canvas.height / 2;

if (e.button === 0) {
  const picker = getFirstSelectedUnit();
  if (picker) {
    const hit = groundItems.find(it => Math.hypot(it.x - wx, it.y - wy) < 18);
    if (hit && unitCanPickup(picker, hit)) {
      draggingPickup = { groundItemId: hit.id, unitId: picker.id };

      dragMouse.x = e.clientX;
      dragMouse.y = e.clientY;

      // CAPTURE events globally so UI can't "steal" the drag
      window.addEventListener("mousemove", onGlobalDragMove, true);
      window.addEventListener("mouseup", onGlobalDragEnd, true);

      e.preventDefault();
      return;
    }
  }
}



  if (e.button === 0) { // left click

    // ===== Build placement =====
  if (buildMode && !localBuildingPlaced) {
    const newBuilding = { x: wx, y: wy, owner: mySid, selected: true, queue: [] };
    buildings.push(newBuilding);
    localBuildingPlaced = true;
    buildMode = false;
    buildBtn.disabled = true;
    socket.emit("place_building", { x: wx, y: wy });
    return;
  }



    // ===== Check for building click =====
    let clickedBuilding = null;
    for (const b of buildings) {
      const bx = canvas.width / 2 + b.x - camera.x;
      const by = canvas.height / 2 + b.y - camera.y;
      const dx = Math.abs(mouse.x - bx);
      const dy = Math.abs(mouse.y - by);
      if (dx < BUILD_W / 2 && dy < BUILD_H / 2) {
        clickedBuilding = b;
        break;
      }
    }

    if (clickedBuilding && clickedBuilding.owner === mySid) {
      buildings.forEach(b => b.selected = false);
      clickedBuilding.selected = true;
      buildingPanel.style.display = "block";
      panel.style.display = "none";
      selecting = false;
      updateSelectedUnits(); // <-- sync panel
      return;
    }

    // ===== Check for unit click =====
    let clickedUnit = null;
    for (const u of myUnits) {
      const ux = canvas.width / 2 + u.x - camera.x;
      const uy = canvas.height / 2 + u.y - camera.y;
      if (Math.hypot(mouse.x - ux, mouse.y - uy) < 20) {
        clickedUnit = u;
        break;
      }
    }

    if (clickedUnit) {
      myUnits.forEach(u => u.selected = false);
      clickedUnit.selected = true;

        updateSelectedUnits(); // <-- sync panel
      selecting = false;
      return;
    }

    // ===== Clicked empty space =====
    buildings.forEach(b => b.selected = false);
    buildingPanel.style.display = "none";
    myUnits.forEach(u => u.selected = false);
    updateSelectedUnits(); // <-- sync panel
    // Start selection box
    selecting = true;
    selectStart.x = mouse.x;
    selectStart.y = mouse.y;
  }
});


canvas.addEventListener("mouseup", (e) => {
  if (e.button !== 0) return;
  if (!draggingPickup) return;

  const gi = groundItems.find(x => x.id === draggingPickup.groundItemId);
  const picker = myUnits.find(u => u.id === draggingPickup.unitId);
  draggingPickup = null;

  if (!gi || !picker) return;

  // Must still be in range at drop time
  if (!unitCanPickup(picker, gi)) return;

  // Must drop onto a slot in the UI
  const slotEl = findSlotElementAtScreen(e.clientX, e.clientY);
  if (!slotEl) return;

  const slotIndex = parseInt(slotEl.dataset.slotIndex, 10);
  const unitId = slotEl.dataset.unitId;

  // Only allow equipping to LOCAL unit equipment panel
  const targetUnit = myUnits.find(u => u.id === unitId);
  if (!targetUnit) return;

  if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null];

  // slot must be empty
  if (targetUnit.itemSlots[slotIndex]) return;

  // equip
  targetUnit.itemSlots[slotIndex] = { id: crypto.randomUUID(), name: gi.name };
  groundItems = groundItems.filter(x => x.id !== gi.id);

  renderUnitItems(targetUnit);
});




canvas.addEventListener("mouseup", e=>{
  if(e.button===0){
    selecting=false;

    const x1=Math.min(selectStart.x,mouse.x);
    const y1=Math.min(selectStart.y,mouse.y);
    const x2=Math.max(selectStart.x,mouse.x);
    const y2=Math.max(selectStart.y,mouse.y);
    for(const u of myUnits){
      const sx=canvas.width/2+u.x-camera.x;
      const sy=canvas.height/2+u.y-camera.y;
      u.selected=(sx>=x1&&sx<=x2 && sy>=y1&&sy<=y2);
    }
    updateSelectedUnits(); // <-- sync panel
  } 

      if(e.button === 2){ // right click
        const wx = camera.x + mouse.x - canvas.width/2;
        const wy = camera.y + mouse.y - canvas.height/2;

        let clickedResource = null;
        let clickedPlayerSid = null;

        for(const r of resources){
            if(Math.hypot(r.x-wx,r.y-wy) < RESOURCE_RADIUS){
                clickedResource = r;
                break;
            }
        }

        if(!clickedResource){
            for(const sid in players){
                if(sid === mySid) continue;
                const p = players[sid];
                if(Math.hypot(p.x-wx,p.y-wy) < 20){
                    clickedPlayerSid = sid;
                    break;
                }
            }
        }

        const selectedUnits = myUnits.filter(u => u.selected);

        selectedUnits.forEach(u => {
            u.targetResource = clickedResource ? clickedResource.id : null;
            u.targetEnemy = null;          // stop attacking
            u.tx = wx;
            u.ty = wy;
            u.manualMove = true;           // allow movement to override combat
            harvesting = null;
        });

        
    }
});

canvas.addEventListener("contextmenu", e=>e.preventDefault());

const createUnitBtn = document.getElementById("createUnitBtn");
createUnitBtn.onclick = () => {
    const selectedBuilding = buildings.find(b => b.selected && b.owner === mySid);
    if (!selectedBuilding) return;

    const radius = BUILD_W / 2 + 30; // spawn outside building
    const unitsToSpawn = 1; // you can increase this if creating multiple units at once

    // Count how many units are already around this building
    const existingUnits = myUnits.filter(u => Math.hypot(u.x - selectedBuilding.x, u.y - selectedBuilding.y) < radius + 20);
    const startIndex = existingUnits.length;

    for (let i = 0; i < unitsToSpawn; i++) {
        const idx = startIndex + i;
        const angle = (idx * 45) * Math.PI / 180; // spread units 45° apart
        const spawnX = selectedBuilding.x + Math.cos(angle) * radius;
        const spawnY = selectedBuilding.y + Math.sin(angle) * radius;

const newUnit = {
    id: crypto.randomUUID(), // or a simple incrementing counter
    x: spawnX,
    y: spawnY,
    tx: spawnX,
    ty: spawnY,
    selected: false,
    targetResource: null,
    targetEnemy: null,
    anim: "idle",
    frame: 0,
    attackFrame: 0,
    dir: "000",
    hp: UNIT_MAX_HEALTH,
    attackCooldown: 0,
    manualMove: false,
    lastX: spawnX,
    lastY: spawnY,
   itemSlots: [
  { id: crypto.randomUUID(), name: "sword" },
  { id: crypto.randomUUID(), name: "shield" }
]
};
myUnits.push(newUnit);
socket.emit("spawn_unit", { unit: newUnit });

    }
};



buildBtn.onclick = ()=>{ if(!localBuildingPlaced) buildMode=true; };

/* ================= COMBAT ================= */
const ATTACK_RANGE = 80;
const DPS = 10; // damage per second

let targetPlayerSid = null;

let playerHealth = {};
const MAX_HEALTH = 100;

/* ================= SOCKET STATE ================= */
// Keep player positions/colors from state
// Update remote units
socket.on("state", state => {

    // Remove players who are no longer on the server
    for (const sid in players) {
        if (!state.players[sid] || !state.players[sid].units.length) {
            delete players[sid];
        }
    }

    // Update or add players
    for (const sid in state.players) {
        if (sid === mySid) continue;

        const serverPlayer = state.players[sid];
        if (!serverPlayer.units || serverPlayer.units.length === 0) {
            // Don't add dead players
            delete players[sid];
            continue;
        }

        if (!players[sid]) players[sid] = { x: 0, y: 0, color: "#fff", units: [] };

        players[sid].x = serverPlayer.x;
        players[sid].y = serverPlayer.y;
        players[sid].color = serverPlayer.color;
        players[sid].units = serverPlayer.units.map(u => ({
            ...u,
            renderFrame: 0,
            renderAttackFrame: 0
        }));
    }

    // Update buildings as before
    buildings = state.buildings.map(sb => {
        const existing = buildings.find(b =>
            b.x === sb.x &&
            b.y === sb.y &&
            b.owner === sb.owner
        );
        return {
            ...sb,
            selected: existing ? existing.selected : false,
            queue: existing ? existing.queue : []
        };
    });
});


socket.on("unit_hp_update", ({ sid, unitId, hp }) => {
    const list = sid === mySid ? myUnits : players[sid]?.units;
    if (!list) return;
    const u = list.find(u => u.id === unitId);
    if (!u) return;

    u.hp = hp;

    if (u.hp <= 0) {
        // remove locally
        const i = list.indexOf(u);
        if (i !== -1) list.splice(i, 1);
    }
});

socket.on("update_units", ({ sid, units }) => {
    if (!players[sid]) players[sid] = { units: [] };

    const localUnits = players[sid].units;

    for (const su of units) {
        let lu = localUnits.find(u => u.id === su.id);

        if (!lu) {
            // New unit from server
            localUnits.push({
                ...su,
                renderFrame: 0,
                renderAttackFrame: 0,
                selected: false
            });
            continue;
        }

        // Always update authoritative fields
        lu.x = su.x;
        lu.y = su.y;
        lu.tx = su.tx;
        lu.ty = su.ty;
        lu.hp = su.hp; 
        lu.dir = su.dir;

        if (lu.anim !== su.anim) {
            lu.anim = su.anim;
            lu.renderFrame = 0;
            lu.renderAttackFrame = 0;
        }

        // Patch server ID if missing
        if (lu.id == null) lu.id = su.id;
    }

    if (sid === mySid) {
        for (let i = 0; i < units.length; i++) {
            if (myUnits[i] && myUnits[i].id !== units[i].id) {
                myUnits[i].id = units[i].id; // ensure id matches server
            }
            myUnits[i].hp = units[i].hp; // also patch HP immediately
        }
    }



    // Only remove units that server truly removed
    players[sid].units = localUnits.filter(lu =>
        units.some(su => su.id === lu.id)
    );
});



let selectedUnits = []; // Array of selected unit IDs
let allUnits = {}; // sid -> units list (updated from server)

// Function to render selected units in panel
function renderUnitPanel() {
    const unitListDiv = document.getElementById("unit-list");
    unitListDiv.innerHTML = ""; // clear

    selectedUnits.forEach(uid => {
        let unit = findUnitById(uid);
        if (!unit) return;

        const unitDiv = document.createElement("div");
        unitDiv.textContent = `Unit ${unit.id.slice(0,4)}`; // show short id
        unitDiv.style.cursor = "pointer";
        unitDiv.style.marginBottom = "5px";
        unitDiv.style.padding = "2px 5px";
        unitDiv.style.border = "1px solid white";
        unitDiv.style.borderRadius = "4px";
        unitDiv.addEventListener("click", () => {
            renderUnitItems(unit);
        });
        unitListDiv.appendChild(unitDiv);
    });
}

function findUnitById(uid) {
    // Prefer local units (they definitely have items)
    const local = myUnits.find(u => u.id === uid);
    if (local) return local;

    for (let sid in allUnits) {
        const unit = (allUnits[sid] || []).find(u => u.id === uid);
        if (unit) return unit;
    }
    return null;
}






function removeDeadUnits(unitsArray) {
    for (let i = unitsArray.length - 1; i >= 0; i--) {
        if (unitsArray[i].hp <= 0) {
            unitsArray.splice(i, 1);
        }
    }
}





/* ================= UPDATE ================= */


function update(){
    // --- CAMERA ---
    if(keys.w) camera.y -= camSpeed;
    if(keys.s) camera.y += camSpeed;
    if(keys.a) camera.x -= camSpeed;
    if(keys.d) camera.x += camSpeed;

    const now = performance.now();


    removeDeadUnits(myUnits);

    for (const sid in players) {
        if (sid === mySid) continue;
        if (!players[sid] || !players[sid].units) continue;
        removeDeadUnits(players[sid].units);
    }


    // --- UNIT LOGIC ---
    for(let i = myUnits.length - 1; i >= 0; i--){
        const u = myUnits[i];

        if(u.hp <= 0){
            myUnits.splice(i, 1);
            continue;
        }

          // --- Manual move ---
  if(u.manualMove){
      const groupSize = myUnits.length;
      const unitIndex = myUnits.indexOf(u);
      const offset = getUnitTargetOffset(unitIndex, groupSize);

      const targetX = u.tx + offset.dx;
      const targetY = u.ty + offset.dy;

      const dx = targetX - u.x;
      const dy = targetY - u.y;
      const dist = Math.hypot(dx, dy);
      if(dist > 1.5){
          const speed = 4.5;
          u.x += (dx / dist) * Math.min(speed, dist);
          u.y += (dy / dist) * Math.min(speed, dist);
          u.anim = "walk";
          u.dir = getDirKey(dx, dy);
          u.frame = (u.frame + ANIM_SPEED) % WALK_FRAMES;
      } else {
          u.x = targetX; 
          u.y = targetY; 
          u.manualMove = false;
          u.anim = "idle";
          u.frame = (u.frame + ANIM_SPEED) % IDLE_FRAMES;
      }
      continue;
  }


        // --- Resource harvesting ---
        if(u.targetResource !== null){
            const r = resources.find(r => r.id === u.targetResource);
            if(r){
                const dist = Math.hypot(u.x - r.x, u.y - r.y);
                if(dist < RESOURCE_RADIUS){
                    if(!harvesting) harvesting = { resourceId: r.id, startTime: now };
                    else if(now - harvesting.startTime >= HARVEST_TIME){
                        resources = resources.filter(rr => rr.id !== r.id);
                        resourceCount++;
                        harvesting = null;
                        u.targetResource = null;
                    }
                } else harvesting = null;
            } else u.targetResource = null;
        }

        // --- Combat & auto-chase ---
        if(!u.manualMove){
            if(!u.targetEnemy || !players[u.targetEnemy.sid]?.units[u.targetEnemy.idx]?.hp){
                u.targetEnemy = null;
            }
            if(!u.targetEnemy){
                const nearest = findNearestEnemy(u);
                if(nearest){
                    const dist = Math.hypot(u.x - nearest.x, u.y - nearest.y);
                    if(dist <= 200) u.targetEnemy = nearest;
                }
            }

         if(u.targetEnemy){
const enemyPlayer = players[u.targetEnemy.sid];
if(!enemyPlayer) { u.targetEnemy = null; continue; }

const enemy = enemyPlayer.units.find(unit => unit.id === u.targetEnemy.unitId);
if(!enemy || enemy.hp <= 0){
    u.targetEnemy = null;
    continue;
}

    const dx = enemy.x - u.x;
    const dy = enemy.y - u.y;
    const dist = Math.hypot(dx, dy);

    if(dist > UNIT_ATTACK_RANGE){
        const moveSpeed = 1.2;
        u.x += (dx / dist) * moveSpeed;
        u.y += (dy / dist) * moveSpeed;
        u.anim = "walk";
        u.dir = getDirKey(dx, dy);
        u.frame = (u.frame + ANIM_SPEED) % WALK_FRAMES;
    } else {
        u.anim = "attack";
        u.attackFrame = (u.attackFrame + ANIM_SPEED) % ATTACK_ANIM_FRAMES;
        if(u.attackCooldown >= ATTACK_COOLDOWN){
            socket.emit("attack_unit", {
                targetSid: u.targetEnemy.sid,
                unitId: u.targetEnemy.unitId,
                damage: UNIT_ATTACK_DPS / 60
            });
            u.attackCooldown = 0;
        }
    }
            } else if(u.anim !== "idle"){
                u.anim = "idle";
                u.frame = (u.frame + ANIM_SPEED) % IDLE_FRAMES;
            }
        }

        // --- Cooldowns ---
        if(u.attackCooldown < ATTACK_COOLDOWN) u.attackCooldown += 16.66;


        u.lastX = u.x;
        u.lastY = u.y;
    }

    if(DEBUG_COLLISIONS){
        for(const u of myUnits){
            applyCollisions(u); // only for drawing, don't push
        }
    }


    // --- SEND STATE TO SERVER ---
const unitStates = myUnits.map(u => ({
    id: u.id,          // ⭐ REQUIRED
    x: u.x,
    y: u.y,
    tx: u.tx,
    ty: u.ty,
    anim: u.anim,
    dir: u.dir
}));
    socket.emit("update_units", { units: unitStates });
}













/*Outside update loop*/


// Update all myUnits
const unitStates = myUnits.map(u => ({
    id: u.id,              // ⭐ REQUIRED
    x: u.x,
    y: u.y,
    tx: u.tx,
    ty: u.ty,
    anim: u.anim,
    dir: u.dir
}));







/* ================= BACKGROUND ================= */
function drawBackground(){
  const cx=canvas.width/2;
  const cy=canvas.height/2;
  const baseCol=Math.floor(camera.x/HALF_W);
  const baseRow=Math.floor(camera.y/HALF_H);
  const range=4;

  for(let r=-range;r<=range;r++){
    for(let c=-range;c<=range;c++){
      const col=baseCol+c;
      const row=baseRow+r;
      const wx=(col-row)*HALF_W;
      const wy=(col+row)*HALF_H;
      ctx.drawImage(tile, cx+wx-camera.x, cy+wy-camera.y);
    }
  }
}

/* ================= DRAW ================= */
const buildingImg = new Image();
buildingImg.src = "static/building.png";
const BUILD_W = 506;
const BUILD_H = 370;

function draw() {
  update();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background
  drawBackground();

  // Draw resources
  for (const r of resources) {
    const x = canvas.width / 2 + r.x - camera.x;
    const y = canvas.height / 2 + r.y - camera.y;
    ctx.drawImage(resourceImg, x - RES_W / 2, y - RES_H / 2, RES_W, RES_H);
  }

  // Draw harvesting progress
  if (harvesting) {
    const r = resources.find(r => r.id === harvesting.resourceId);
    if (r) {
      const progress = Math.min(1, (performance.now() - harvesting.startTime) / HARVEST_TIME);
      const x = canvas.width / 2 + r.x - camera.x;
      const y = canvas.height / 2 + r.y - camera.y - 40;

      ctx.fillStyle = "black";
      ctx.fillRect(x - 30, y, 60, 6);
      ctx.fillStyle = "lime";
      ctx.fillRect(x - 30, y, 60 * progress, 6);
    }
  }

  // Draw trees (depth-sorted)
  const visibleTrees = trees.slice().sort((a, b) => a.y - b.y);
  for (const t of visibleTrees) {
    const x = canvas.width / 2 + t.x - camera.x;
    const y = canvas.height / 2 + t.y - camera.y;
    ctx.drawImage(treeImg, x - TREE_W / 2, y - TREE_H, TREE_W, TREE_H);
  }

  // Draw other players
// Other players
for (const sid in players) {
    if (sid === mySid) continue;
    const p = players[sid];



        let frames, framesShadow, drawFrame;

for (const u of p.units) {
    if (u.anim === "attack") {
        frames = playerSprites.attack[u.dir];
        framesShadow = playerSprites.attackshadow[u.dir];
        u.renderAttackFrame += ANIM_SPEED;
        if (u.renderAttackFrame >= ATTACK_ANIM_FRAMES) u.renderAttackFrame = 0;
        drawFrame = Math.floor(u.renderAttackFrame);
    } else if (u.anim === "walk") {
        frames = playerSprites.walk[u.dir];
        framesShadow = playerSprites.walkshadow[u.dir];
        u.renderFrame += ANIM_SPEED;
        if (u.renderFrame >= WALK_FRAMES) u.renderFrame = 0;
        drawFrame = Math.floor(u.renderFrame);
    } else { // idle
        frames = playerSprites.idle[u.dir];
        framesShadow = playerSprites.idleshadow[u.dir];
        u.renderFrame += ANIM_SPEED;
        if (u.renderFrame >= IDLE_FRAMES) u.renderFrame = 0;
        drawFrame = Math.floor(u.renderFrame);
    }

        const img = frames[drawFrame];
        const imgShadow = framesShadow[drawFrame];

        const x = canvas.width/2 + u.x - camera.x;
        const y = canvas.height/2 + u.y - camera.y;

        if (imgShadow && imgShadow.complete) ctx.drawImage(imgShadow, x - SPRITE_W/2, y - SPRITE_H/2, SPRITE_W, SPRITE_H);
        if (img && img.complete) ctx.drawImage(img, x - SPRITE_W/2, y - SPRITE_H/2, SPRITE_W, SPRITE_H);

        // Health bar
        const barWidth = 40;
        const barHeight = 5;
        ctx.fillStyle = "red";
        ctx.fillRect(x - barWidth / 2, y - 30, barWidth, barHeight);
        ctx.fillStyle = "green";
        ctx.fillRect(x - barWidth / 2, y - 30, barWidth * (u.hp / 100), barHeight);
    }
}


  // Draw my units
  for (const u of myUnits) {
    const x = canvas.width / 2 + u.x - camera.x;
    const y = canvas.height / 2 + u.y - camera.y;

    let frames, framesShadow;
    if (u.anim === "walk") {
      frames = playerSprites.walk[u.dir];
      framesShadow = playerSprites.walkshadow[u.dir];

      if (u.frame >= WALK_FRAMES) u.frame = 0;
    } else if (u.anim === "idle") {
      frames = playerSprites.idle[u.dir];
      framesShadow = playerSprites.idleshadow[u.dir];

      if (u.frame >= IDLE_FRAMES) u.frame = 0;
    } else if (u.anim === "attack") {
      frames = playerSprites.attack[u.dir];
      framesShadow = playerSprites.attackshadow[u.dir];
      u.attackFrame += ANIM_SPEED;
      if (u.attackFrame >= ATTACK_ANIM_FRAMES) u.attackFrame = 0;
    } else {
      frames = playerSprites.idle[u.dir];
      framesShadow = playerSprites.idleshadow[u.dir];
    }

    const img = frames[u.anim === "attack" ? Math.floor(u.attackFrame) : Math.floor(u.frame)];
    const imgShadow = framesShadow[u.anim === "attack" ? Math.floor(u.attackFrame) : Math.floor(u.frame)];

    if (imgShadow && imgShadow.complete) ctx.drawImage(imgShadow, x - SPRITE_W / 2, y - SPRITE_H / 2, SPRITE_W, SPRITE_H);
    if (img && img.complete) ctx.drawImage(img, x - SPRITE_W / 2, y - SPRITE_H / 2, SPRITE_W, SPRITE_H);

    // Health bar
    const barWidth = 40;
    const barHeight = 5;
    ctx.fillStyle = "red";
    ctx.fillRect(x - barWidth / 2, y - 30, barWidth, barHeight);
    ctx.fillStyle = "green";
    ctx.fillRect(x - barWidth / 2, y - 30, barWidth * (u.hp / 100), barHeight);

    // Name and selection circle
    ctx.fillStyle = "white";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.fillText("YOU", x, y - 40);

    if (u.selected) {
      ctx.strokeStyle = "yellow";
      ctx.beginPath();
      ctx.arc(x, y + SPRITE_H / 4, 18, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Draw buildings
  for (const b of buildings) {
    const bx = canvas.width / 2 + b.x - camera.x;
    const by = canvas.height / 2 + b.y - camera.y;

    ctx.drawImage(buildingImg, bx - BUILD_W / 2, by - BUILD_H / 2, BUILD_W, BUILD_H);

    if (b.selected) {
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(bx - BUILD_W / 2, by - BUILD_H / 2, BUILD_W, BUILD_H);
      ctx.setLineDash([]);
    }
  }

  // Hover outlines
  if (hoveredResource) {
    const x = canvas.width / 2 + hoveredResource.x - camera.x;
    const y = canvas.height / 2 + hoveredResource.y - camera.y;

    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, RESOURCE_RADIUS, 0, Math.PI * 2);
    ctx.stroke();
  }

  if (hoveredPlayerSid && players[hoveredPlayerSid]) {
    const p = players[hoveredPlayerSid];
    const x = canvas.width / 2 + p.x - camera.x;
    const y = canvas.height / 2 + p.y - camera.y;

    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.rect(x - 14, y - 14, 28, 28);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Building placement preview
  if (buildMode) {
    ctx.globalAlpha = 0.5;
    const wx = camera.x + mouse.x - canvas.width / 2;
    const wy = camera.y + mouse.y - canvas.height / 2;
    const bx = canvas.width / 2 + wx - camera.x;
    const by = canvas.height / 2 + wy - camera.y;
    ctx.drawImage(buildingImg, bx - BUILD_W / 2, by - BUILD_H / 2, BUILD_W, BUILD_H);
    ctx.globalAlpha = 1;
  }

  // Selection box
  if (selecting) {
    ctx.strokeStyle = "white";
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(selectStart.x, selectStart.y, mouse.x - selectStart.x, mouse.y - selectStart.y);
    ctx.setLineDash([]);
  }

  // Panels logic
  const selectedBuilding = buildings.find(b => b.selected);
  const selectedUnits = myUnits.filter(u => u.selected);

  if (selectedBuilding) {
    buildingPanel.style.display = "block";
    panel.style.display = "none";
  } else if (selectedUnits.length > 0) {
    panel.style.display = "block";
    buildingPanel.style.display = "none";
  } else {
    panel.style.display = "none";
    buildingPanel.style.display = "none";
  }



// pick a "current unit" for pickup distance checks: first selected local unit
const picker = myUnits.find(u => u.selected) || null;

const visibleItems = groundItems.slice().sort((a,b)=>a.y-b.y);
for (const it of visibleItems) {
  const sx = canvas.width/2 + it.x - camera.x;
  const sy = canvas.height/2 + it.y - camera.y;

  // icon / fallback
  const icon = itemIcons[it.name];
  if (icon && icon.complete && icon.naturalWidth > 0) {
    ctx.drawImage(icon, sx - GROUND_ITEM_SIZE/2, sy - GROUND_ITEM_SIZE/2, GROUND_ITEM_SIZE, GROUND_ITEM_SIZE);
  } else {
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    ctx.beginPath();
    ctx.arc(sx, sy, 14, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "white";
    ctx.stroke();
  }

  // name above item (always)
  ctx.fillStyle = "white";
  ctx.font = "12px monospace";
  ctx.textAlign = "center";
  ctx.fillText(it.name, sx, sy - 22);

  // show pickup range indicator if a selected unit is near enough
  if (picker && unitCanPickup(picker, it)) {
    ctx.strokeStyle = "lime";
    ctx.beginPath();
    ctx.arc(sx, sy, 18, 0, Math.PI*2);
    ctx.stroke();
  }
}

  if (draggingPickup) {
    const gi = groundItems.find(x => x.id === draggingPickup.groundItemId);
    if (gi) {
      const icon = itemIcons[gi.name];
      const mx = dragMouse.x;
      const my = dragMouse.y;

      ctx.globalAlpha = 0.85;
      if (icon && icon.complete && icon.naturalWidth > 0) {
        ctx.drawImage(icon, mx - 16, my - 16, 32, 32);
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.arc(mx, my, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.fillStyle = "white";
        ctx.font = "10px monospace";
        ctx.textAlign = "center";
        ctx.fillText(gi.name, mx, my - 18);
      }
      ctx.globalAlpha = 1;
    }
  }




  // HUD update (safe use of selectedUnits)
  hud.innerText = `Camera: ${camera.x | 0}, ${camera.y | 0}
Resources: ${resourceCount}
Selected: ${selectedUnits.length}`;

  requestAnimationFrame(draw);
}



tile.onload = draw;
</script>
</body>
</html>