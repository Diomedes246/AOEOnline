  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="utf-8">
  <title>Isometric Multiplayer RTS</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; }
  canvas { display:block; }
  #hud {
    position:fixed;
    top:10px; left:10px;
    color:white;
    font-family:monospace;
    background:rgba(0,0,0,0.5);
    padding:6px;
  }
  #panel {
    position:fixed;
    bottom:20px;
    left:20px;
    width:220px;
    height:120px;
    background:rgba(30,30,30,0.85);
    border:2px solid #888;
    padding:10px;
    color:white;
    font-family:monospace;
    display:none;
  }

  #buildBtn {
    width:100%;
    height:40px;
    margin-top:10px;
    background:#444;
    color:white;
    border:1px solid #aaa;
    cursor:pointer;
  }
  #buildBtn:hover { background:#666; }
  #buildBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
    #mineBtn {
      width:100%;
      height:40px;
      margin-top:10px;
      background:#444;
      color:white;
      border:1px solid #aaa;
      cursor:pointer;
    }
    #mineBtn:hover { background:#666; }
    #mineBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
  </style>
  </head>

  <body>
  <canvas id="game"></canvas>
  <div id="hud"></div>

  <div id="panel">
    <div>Unit Selected</div>
    <button id="buildBtn">Place Town Center</button>
    <button id="mineBtn">Place Mine</button>
  </div>

  <div id="buildingPanel" style="display:none; position:fixed; bottom:20px; left:20px; width:220px; height:120px; background:rgba(30,30,30,0.85); border:2px solid #888; padding:10px; color:white; font-family:monospace;">
    <div>Town Center Selected</div>
    <button id="createUnitBtn">Create Unit</button>
  </div>

  <div id="unit-panel" style="position:fixed; right:10px; top:10px; width:200px; background:rgba(0,0,0,0.7); color:white; padding:10px; border-radius:8px;">
      <h3>Selected Units</h3>
      <div id="unit-list"></div>
      <div id="unit-items" style="margin-top:10px;">
          <h4>Unit Items</h4>
          <ul id="items-list"></ul>
      </div>
  </div>

  <div id="editorPanel" style="
    position:fixed;
    right:10px;
    bottom:10px;
    width:240px;
    background:rgba(0,0,0,0.75);
    color:white;
    padding:10px;
    border-radius:8px;
    font-family:monospace;
    z-index:1000;
  ">
    <button id="editorBtn" style="width:100%; height:36px;">Editor: OFF</button>
  <div style="margin-top:10px;">
    <div>Brush:</div>
    <select id="brushSelect" style="width:100%; height:30px;">
      <option value="" disabled selected>Loading tiles…</option>
    </select>
    <div style="margin-top:10px; font-size:12px; opacity:0.9;">
      Left click: place<br/>
      Shift+Left click: delete<br/>
      c: toggle collision<br/>
      Scroll: collision size<br/>
      Shift+Scroll: tile size 
    </div>
    <button id="entityBtn" style="width:100%; height:36px; margin-top:8px;">
    Entity: OFF
  </button>
  </div>
  </div>
  <div id="entityPanel" style="
    display:none;
    position:fixed;
    left:20px;
    bottom:160px;
    width:320px;
    background:rgba(0,0,0,0.85);
    color:white;
    padding:12px;
    border-radius:10px;
    border:2px solid #777;
    font-family:monospace;
    z-index:2000;
  ">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:bold;">Entity Inspector</div>
      <button id="entityCloseBtn" style="height:26px;">X</button>
    </div>

    <div style="margin-top:10px; font-size:12px; opacity:0.8;" id="entityIdLine"></div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Title</div>
      <input id="entityTitleInput" style="width:100%; height:30px;"/>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Biography</div>
      <textarea id="entityBioInput" style="width:100%; height:90px;"></textarea>
    </div>

    <div style="margin-top:10px;">
      <div style="display:flex; gap:8px; align-items:center;">
        <div style="font-size:12px; opacity:0.8; flex:1;">Actions</div>
        <button id="entityAddActionBtn" style="height:26px;">+ Add</button>
      </div>
      <div id="entityActionsList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:6px;"></div>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Items</div>
      <ul id="entity-items-list" style="margin-top:6px; list-style:none; padding:0;"></ul>
    </div>

    <div style="margin-top:10px;">
      <div style="font-size:12px; opacity:0.8;">Abilities</div>
      <div id="entity-abilities-list" style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;"></div>
    </div>

    <div style="margin-top:10px; display:flex; gap:8px;">
      <button id="entitySaveBtn" style="flex:1; height:34px;">Save</button>
      <button id="entityDeleteBtn" style="flex:1; height:34px;">Delete</button>
    </div>
  </div>




  <script>
  const canvas = document.getElementById("game");
  // Loading overlay + image loader instrumentation
  (function(){
    const overlay = document.createElement('div');
    overlay.id = 'loadingOverlay';
    overlay.style.position = 'fixed';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.right = '0';
    overlay.style.bottom = '0';
    overlay.style.background = '#000';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.zIndex = '99999';
    overlay.style.flexDirection = 'column';
    overlay.style.color = 'white';
    overlay.innerHTML = `
      <div style="font-family:monospace; font-size:18px; margin-bottom:12px;">Loading assets...</div>
      <div style="width:60%; max-width:520px; background:rgba(255,255,255,0.08); padding:6px; border-radius:6px;">
        <div id="loadingBarInner" style="height:18px; width:0%; background:linear-gradient(90deg,#4ee,#08f); border-radius:4px;"></div>
      </div>
      <div id="loadingPercent" style="font-family:monospace; margin-top:8px; opacity:0.9;">0%</div>
    `;
    document.body.appendChild(overlay);

    window.__loader = {
      total: 0,
      loaded: 0,
      errored: 0,
      _lastChange: Date.now(),
      _checkTimer: null,
      update() {
        const inner = document.getElementById('loadingBarInner');
        const pctEl = document.getElementById('loadingPercent');
        const total = Math.max(1, this.total);
        const done = Math.min(this.loaded + this.errored, total);
        const pct = Math.floor((done / total) * 100);
        if (inner) inner.style.width = pct + '%';
        if (pctEl) pctEl.textContent = pct + '%';

        // If everything loaded right now, wait a short quiescence period
        // to allow any late Image() constructions to register.
        if (done >= this.total) {
          const now = Date.now();
          const sinceChange = now - (this._lastChange || 0);
          const QUIESCE = 400; // ms
          clearTimeout(this._checkTimer);
          if (sinceChange >= QUIESCE) {
            window.ASSETS_LOADED = true;
            setTimeout(() => { overlay.style.display = 'none'; }, 120);
          } else {
            // schedule a recheck after the remaining quiesce interval
            this._checkTimer = setTimeout(() => this.update(), QUIESCE - sinceChange + 10);
          }
        }
      }
    };

    // Monkeypatch Image to auto-register loads
    const NativeImage = window.Image;
    function LoaderImage() {
      const img = new NativeImage();
      try { window.__loader.total++; window.__loader._lastChange = Date.now(); } catch(e){}
      img.addEventListener('load', function(){ try{ window.__loader.loaded++; window.__loader.update(); }catch(e){} });
      img.addEventListener('error', function(){ try{ window.__loader.errored++; window.__loader.update(); }catch(e){} });
      return img;
    }
    LoaderImage.prototype = NativeImage.prototype;
    window.Image = LoaderImage;
    // start as not loaded
    window.ASSETS_LOADED = false;
  })();
  let editorMode = false;
  let entityMode = false;
  let editorTileW = 256;
  let editorTileH = 256;
  let editorTileAspect = 1;
  let editorTileOverride = false;
  let editorCollisionEnabled = true;
  let editorCollisionW = 64;
  let editorCollisionH = 64;

  // Global variables
  let camera = {x:0,y:0};
  let groundItems = [];
  let trees = [];
  let resources = [];
  let buildings = [];
  let myUnits = [];
  let players = {};
  let resourceCounts = { red: 0, green: 0, blue: 0 };
  window.resourceCounts = resourceCounts;
  let hoveredResource = null;
  let hoveredPlayerSid = null;
  let hoveredAttackEntity = null;
  let dragMouse = {x:0,y:0};
  let selecting = false;
  let selectStart = {x:0,y:0};
  let mouse = {x:0,y:0};
  let buildMode = false;
  let localBuildingPlaced = false;
    let mineMode = false;
    let localMinePlaced = false;
  const socket = io({autoConnect: false});
  socket.on("server_debug", (data) => { try { console.log("SERVER_DEBUG:", data.msg); } catch(e){} });
  // Building image and default size (needed by static/draw.js)
  const BUILD_W = 256;
  const BUILD_H = 256;
  const buildingImg = new Image();
  buildingImg.src = "static/tiles/building.png";
  // Mine image and default size (used by mine placement ghost)
  const MINE_W = 256;
  const MINE_H = 256;
  const mineImg = new Image();
  mineImg.src = "static/tiles/mine.png";
  // Client-side per-town-center population limit (used for HUD cap calculation)
  const POP_LIMIT = 10;
  // How many town centers a player may place
  const BUILD_LIMIT = 1;
  // Cost in resources to place a town center
  const TOWN_CENTER_COST = 5;
  </script>

  <script src="static/input.js"></script>
  <script src="static/update.js"></script>
  <script src="static/draw.js"></script>
  <script src="static/editor.js"></script>

  <script>
  /* ================= SETUP ================= */
  const ctx = canvas.getContext("2d");
  const hud = document.getElementById("hud");
  const panel = document.getElementById("panel");
  const buildBtn = document.getElementById("buildBtn");
  const mineBtn = document.getElementById("mineBtn");

  function updateBuildButton() {
    if (!buildBtn) return;
    const owned = (mapObjects || []).filter(o => o.kind === 'town_center' && o.owner === mySid).length;
    buildBtn.innerText = `Place Town Center (Cost: ${TOWN_CENTER_COST} red) (${owned}/${BUILD_LIMIT})`;
    // disable if reached build limit or not enough red resources
    buildBtn.disabled = (owned >= BUILD_LIMIT) || ((resourceCounts.red || 0) < TOWN_CENTER_COST);
    buildBtn.title = `Cost: ${TOWN_CENTER_COST} resources`;
  }

  function updateMineButton() {
    if (!mineBtn) return;
    const mineCost = 3;
    mineBtn.innerText = `Place Mine (Cost: ${mineCost} blue)`;
    mineBtn.disabled = ((resourceCounts.blue || 0) < mineCost);
    mineBtn.title = `Cost: ${mineCost} blue resources`;
  }

  // Entity inspector elements (used by openEntityInspector / input handlers)
  const entityPanelEl = document.getElementById("entityPanel");
  const entityIdLine = document.getElementById("entityIdLine");
  const entityTitleInput = document.getElementById("entityTitleInput");
  const entityBioInput = document.getElementById("entityBioInput");
  const entityAddActionBtn = document.getElementById("entityAddActionBtn");
  const entityActionsList = document.getElementById("entityActionsList");
  const entitySaveBtn = document.getElementById("entitySaveBtn");
  const entityDeleteBtn = document.getElementById("entityDeleteBtn");
  const entityCloseBtn = document.getElementById("entityCloseBtn");

  let selectedEntityId = null;
  let draggingPickup = null;

  if (entityCloseBtn) {
    entityCloseBtn.onclick = () => {
      if (entityPanelEl) entityPanelEl.style.display = "none";
      selectedEntityId = null;
      try { if (window.__mineCountdownTimer) { clearInterval(window.__mineCountdownTimer); window.__mineCountdownTimer = null; } } catch(e){}
    };
  }

  let mySid = null;
  socket.on("connect", () => {
    mySid = socket.id;

    // ✅ request initial map after connection is established
    socket.emit("request_state");
    socket.emit("request_map");
  });


  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  let DEBUG_COLLISIONS = true; // toggle on/off


  function setEntityInspectorEditable(canEdit) {
    entityTitleInput.disabled = !canEdit;
    entityBioInput.disabled = !canEdit;

    entityAddActionBtn.disabled = !canEdit;
    entitySaveBtn.disabled = !canEdit;
    entityDeleteBtn.disabled = !canEdit;

    // Optional visual cue
    entityTitleInput.style.opacity = canEdit ? "1" : "0.7";
    entityBioInput.style.opacity   = canEdit ? "1" : "0.7";
  }


  /* ================= PLAYER SPRITES ================= */

  const SPRITE_W = 256;
  const SPRITE_H = 256;
  const DIRECTIONS = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337];
  const IDLE_FRAMES = 24;
  const WALK_FRAMES = 24;
  const ANIM_SPEED = 0.3;


  const UNIT_RADIUS = 18;
  const PLAYER_RADIUS = 20;
  const TREE_RADIUS = 140;
  const RESOURCE_RADIUS_COLLIDE = 15;

  // Buildings use rectangle collision
  const BUILD_COLLISION_PADDING = -50;


  const UNIT_ATTACK_RANGE = PLAYER_RADIUS + UNIT_RADIUS + 10; // 10 extra for buffer
  const UNIT_ATTACK_DPS = 30; // damage per second
  const ATTACK_COOLDOWN = 1000 / 60; // 1 tick per frame (60fps)
  const UNIT_MAX_HEALTH = 100;
  const ATTACK_ANIM_FRAMES = 24;


  // groundItems declared earlier in the global setup

  const itemIcons = {
    sword: new Image(),
    shield: new Image()
  };
  itemIcons.sword.src = "static/items/sword.png";   // make these files
  itemIcons.shield.src = "static/items/shield.png"; // or draw text fallback
  const GROUND_ITEM_SIZE = 32;
  const PICKUP_RADIUS = 26;

  const PICKUP_DISTANCE = 120; // how close unit must be to pick up from ground
  let currentItemsUnitId = null; // which unit's equipment UI is currently showing


  function unitCanPickup(unit, groundItem) {
    return Math.hypot(unit.x - groundItem.x, unit.y - groundItem.y) <= PICKUP_DISTANCE;
  }

  
  // `draggingPickup` and `dragMouse` are declared in the main globals block; do not re-declare here.


  function getFirstSelectedUnit() {
    return myUnits.find(u => u.selected) || null;
  }
  function onGlobalDragMove(e) {
    // keep mouse updated even over UI
    dragMouse.x = e.clientX;
    dragMouse.y = e.clientY;

    // optional: block text selection while dragging
    e.preventDefault();
  }

  // onGlobalDragEnd moved to static/input.js

  function renderUnitItems(unit) {
    currentItemsUnitId = unit.id;

    const itemsList = document.getElementById("items-list");
    itemsList.innerHTML = "";

    if (!unit.itemSlots) unit.itemSlots = [null, null, null, null, null];

    for (let i = 0; i < 5; i++) {
      const slot = unit.itemSlots[i];

      const li = document.createElement("li");
      li.style.display = "flex";
      li.style.alignItems = "center";
      li.style.justifyContent = "space-between";
      li.style.border = "1px solid #777";
      li.style.borderRadius = "6px";
      li.style.padding = "6px";
      li.style.marginBottom = "6px";
      li.style.background = "rgba(255,255,255,0.05)";

      li.dataset.slotIndex = String(i);
      li.dataset.unitId = unit.id;

      const left = document.createElement("div");
      left.textContent = `Slot ${i + 1}: ${slot ? slot.name : "(empty)"}`;
      li.appendChild(left);

      // Allow dropping from ground -> slot OR slot -> slot
      li.addEventListener("dragover", (e) => {
        e.preventDefault();
        li.style.outline = "2px dashed #fff";
      });
      li.addEventListener("dragleave", () => {
        li.style.outline = "";
      });

      li.addEventListener("drop", (e) => {
        e.preventDefault();
        li.style.outline = "";

        const payloadStr = e.dataTransfer.getData("application/json");
        if (!payloadStr) return;

        let payload;
        try { payload = JSON.parse(payloadStr); } catch { return; }

        const targetUnit = myUnits.find(u => u.id === unit.id);
        if (!targetUnit) return;
        if (!targetUnit.itemSlots) targetUnit.itemSlots = [null, null, null, null, null];

        const slotIndex = i;

    if (payload.type === "ground_item") {
      socket.emit("pickup_item", {
        unitId: unit.id,
        slotIndex: i,
        groundItemId: payload.groundItemId
      });
      // Optimistic local update: remove ground item and add to unit slot
      try {
        const giIndexLocal = groundItems.findIndex(g => g.id === payload.groundItemId);
        if (giIndexLocal !== -1) groundItems.splice(giIndexLocal, 1);
        unit.itemSlots = unit.itemSlots || [];
        unit.itemSlots[i] = { id: ("local-" + (payload.groundItemId || Math.random())), name: (payload.name || "item") };
        if (currentItemsUnitId === unit.id) renderUnitItems(unit);
      } catch (ex) { console.error("optimistic pickup_item failed", ex); }
      return;
    }

        // If dropping an entity item onto a unit slot
        if (payload.type === "entity_item") {
          // payload: { type: 'entity_item', entityId, slotIndex, item }
          socket.emit("entity_give_to_unit", {
            entityId: payload.entityId,
            entitySlotIndex: payload.slotIndex,
            unitId: unit.id,
            slotIndex: i
          });
          return;
        }

        // If dropping a unit item (slot -> slot) (optional nice feature):
        if (payload.type === "unit_item") {
          const fromUnit = myUnits.find(u => u.id === payload.unitId);
          if (!fromUnit || !fromUnit.itemSlots) return;

          const fromSlot = payload.slotIndex;
          const moving = fromUnit.itemSlots[fromSlot];
          if (!moving) return;

          // If target slot occupied, swap
          const temp = targetUnit.itemSlots[slotIndex];
          targetUnit.itemSlots[slotIndex] = moving;
          fromUnit.itemSlots[fromSlot] = temp || null;

          renderUnitItems(targetUnit);
          return;
        }
      });

      // If slot has item: make it draggable out
      if (slot) {
        const chip = document.createElement("div");
        chip.textContent = "drag";
        chip.style.padding = "3px 8px";
        chip.style.border = "1px solid #aaa";
        chip.style.borderRadius = "6px";
        chip.style.cursor = "grab";
        chip.style.userSelect = "none";
        chip.style.background = "rgba(0,0,0,0.3)";
        chip.draggable = true;

        chip.addEventListener("dragstart", (e) => {
          const payload = {
            type: "unit_item",
            unitId: unit.id,
            slotIndex: i,
            item: slot
          };
          e.dataTransfer.setData("application/json", JSON.stringify(payload));
          e.dataTransfer.effectAllowed = "move";
        });

        li.appendChild(chip);
      }

      itemsList.appendChild(li);
    }
  }




  canvas.addEventListener("dragover", (e) => {
    e.preventDefault(); // allow drop
  });

  canvas.addEventListener("drop", (e) => {
    e.preventDefault();

    const payloadStr = e.dataTransfer.getData("application/json");
    if (!payloadStr) return;

    let payload;
    try { payload = JSON.parse(payloadStr); } catch { return; }

    // Convert screen -> world
    const wx = camera.x + e.clientX - canvas.width / 2;
    const wy = camera.y + e.clientY - canvas.height / 2;

    // Dropping equipment item onto world => SERVER creates ground item
    if (payload.type === "unit_item") {
      socket.emit("drop_item", {
        unitId: payload.unitId,
        slotIndex: payload.slotIndex,
        x: wx,
        y: wy
      });
      return;
    }
    // Dropping an item from an entity onto the world -> create ground item
    if (payload.type === "entity_item") {
      console.log('canvas drop: entity_item', { payload, socketConnected: socket && socket.connected, wx, wy });
      // optimistic: remove from entity UI and add local ground item for immediate feedback
      try {
        const ent = (mapObjects || []).find(m => m.id === payload.entityId);
        let itemName = null;
        if (ent && ent.itemSlots && ent.itemSlots[payload.slotIndex]) {
          const it = ent.itemSlots[payload.slotIndex];
          itemName = it && it.name;
          ent.itemSlots[payload.slotIndex] = null;
          if (selectedEntityId === ent.id) openEntityInspector(ent);
        }
        const localGi = { id: 'local-' + (Date.now() + Math.floor(Math.random()*1000)), name: itemName || 'item', x: wx, y: wy };
        groundItems = groundItems || [];
        groundItems.push(localGi);
      } catch (ex) { console.error('optimistic entity->ground failed', ex); }

      socket.emit("entity_give_to_ground", {
        entityId: payload.entityId,
        entitySlotIndex: payload.slotIndex,
        x: wx,
        y: wy
      });

      return;
    }
  });




  function ensureEntityMeta(o) {
    if (!o.meta) o.meta = {};
    if (!o.meta.entity) o.meta.entity = true;
    if (typeof o.meta.title !== "string") o.meta.title = "";
    if (typeof o.meta.bio !== "string") o.meta.bio = "";
    if (!Array.isArray(o.meta.actions)) o.meta.actions = [];
  }

  function getDefaultEntityTitle(o) {
    if (o.type === "building") return "Building";
    if (o.type === "tile") return o.kind ? prettyName(o.kind) : "Tile";
    return "Entity";
  }

  function openEntityInspector(o) {
    ensureEntityMeta(o);
    selectedEntityId = o.id;

    const ownerLabel = o.owner ? (players[o.owner]?.color ? o.owner.slice(0,6) : o.owner.slice(0,6)) : "(none)";
    
    // Build info line with size and collision info for tiles
    let infoLine = `id: ${o.id} | type: ${o.type}${o.kind ? " | kind: " + o.kind : ""} | owner: ${ownerLabel}`;
    
    if (o.type === "tile" && o.meta) {
      const tileW = o.meta.w || 0;
      const tileH = o.meta.h || 0;
      const collisionW = o.meta.cw || 0;
      const collisionH = o.meta.ch || 0;
      const collisionEnabled = o.meta.collides || false;
      
      infoLine += ` | size: ${tileW}x${tileH}`;
      if (collisionEnabled) {
        infoLine += ` | collision: ${collisionW}x${collisionH}`;
      } else {
        infoLine += ` | collision: OFF`;
      }
    }
    
    entityIdLine.textContent = infoLine;

    entityTitleInput.value = o.meta.title || getDefaultEntityTitle(o);
    entityBioInput.value = o.meta.bio || "";

    renderEntityActions(o);

    // ✅ Only allow editing TILE title/bio when editor mode is ON
    const isTile = (o.type === "tile");
    const canEdit = !(isTile && !editorMode);
    setEntityInspectorEditable(canEdit);

    // Optional: make it obvious why it's locked
    if (!canEdit) {
      entityIdLine.textContent += "  |  (read-only: enable Editor to edit tile text)";
    }

    // Render entity item slots
    const entityItemsEl = document.getElementById("entity-items-list");
    if (entityItemsEl) {
      entityItemsEl.innerHTML = "";
      // If in editor mode, show controls to add/remove persistent item slots
      if (editorMode) {
        const ctrl = document.createElement("div");
        ctrl.style.display = "flex";
        ctrl.style.gap = "6px";
        ctrl.style.marginBottom = "6px";

        const inc = document.createElement("button");
        inc.textContent = "+ Slot";
        inc.style.height = "26px";
        inc.onclick = () => {
          o.itemSlots = o.itemSlots || [];
          o.itemSlots.push(null);
          socket.emit("update_map_object", { id: o.id, itemSlots: o.itemSlots });
          // re-open inspector to reflect change
          openEntityInspector(o);
        };

        const dec = document.createElement("button");
        dec.textContent = "- Slot";
        dec.style.height = "26px";
        dec.onclick = () => {
          o.itemSlots = o.itemSlots || [];
          if (o.itemSlots.length === 0) return;
          // prevent removing a non-empty slot
          const last = o.itemSlots[o.itemSlots.length - 1];
          if (last) { alert("Cannot remove slot: last slot is not empty."); return; }
          o.itemSlots.pop();
          socket.emit("update_map_object", { id: o.id, itemSlots: o.itemSlots });
          openEntityInspector(o);
        };

        ctrl.appendChild(inc);
        ctrl.appendChild(dec);
        entityItemsEl.appendChild(ctrl);
      }
      const slots = o.itemSlots || [];
      const slotCount = Math.max(2, slots.length);

      // container that will wrap slot elements (prevents vertical stacking)
      const slotsContainer = document.createElement("div");
      slotsContainer.style.display = "flex";
      slotsContainer.style.flexWrap = "wrap";
      slotsContainer.style.gap = "6px";
      slotsContainer.style.alignItems = "flex-start";

      const compact = slotCount > 3;

      for (let si = 0; si < slotCount; si++) {
        const s = slots[si] || null;
        const li = document.createElement("li");
        li.dataset.slotIndex = si;
        li.dataset.entityId = o.id;

        if (compact) {
          // small square slot
          li.style.width = "40px";
          li.style.height = "40px";
          li.style.display = "inline-flex";
          li.style.alignItems = "center";
          li.style.justifyContent = "center";
          li.style.border = "1px solid #666";
          li.style.borderRadius = "4px";
          li.style.background = s ? "rgba(255,255,255,0.06)" : "transparent";
          li.title = s ? (s.name || "item") : `(empty)`;
          const dot = document.createElement("div");
          dot.style.width = "22px";
          dot.style.height = "22px";
          dot.style.borderRadius = "3px";
          dot.style.background = s ? "rgba(200,200,200,0.9)" : "rgba(0,0,0,0.15)";
          dot.style.display = "flex";
          dot.style.alignItems = "center";
          dot.style.justifyContent = "center";
          dot.style.fontSize = "11px";
          dot.style.color = "#000";
          dot.textContent = s ? (s.name ? s.name[0].toUpperCase() : "I") : "";
          li.appendChild(dot);
          li._dot = dot;
        } else {
          li.style.display = "flex";
          li.style.justifyContent = "space-between";
          li.style.alignItems = "center";
          li.style.border = "1px solid #666";
          li.style.padding = "6px";
          li.style.marginBottom = "6px";
          const left = document.createElement("div");
          left.textContent = `Slot ${si+1}: ${s ? s.name : "(empty)"}`;
          li.appendChild(left);
        }

        // allow dropping unit_item onto entity slot
        li.addEventListener("dragover", (e) => { e.preventDefault(); li.style.outline = "2px dashed #fff"; });
        li.addEventListener("dragleave", () => { li.style.outline = ""; });
        li.addEventListener("drop", (e) => {
          e.preventDefault(); li.style.outline = "";
          const payloadStr = e.dataTransfer.getData("application/json");
          if (!payloadStr) return;
          let payload; try { payload = JSON.parse(payloadStr); } catch { return; }
          // dropping a unit item onto entity
          console.log("entity-slot drop", { entityId: o.id, slotIndex: si, payload });
          if (payload.type === "unit_item") {
            socket.emit("unit_give_to_entity", {
              unitId: payload.unitId,
              unitSlotIndex: payload.slotIndex,
              entityId: o.id,
              entitySlotIndex: si
            });
          }
        });

        // if slot has item, make draggable
        if (s) {
          const chip = document.createElement("div");
          chip.textContent = s.name || "item";
          chip.style.padding = "3px 8px";
          chip.style.border = "1px solid #aaa";
          chip.style.borderRadius = "6px";
          chip.style.cursor = "grab";
          chip.draggable = true;
          chip.addEventListener("dragstart", (e) => {
            const payload = { type: "entity_item", entityId: o.id, slotIndex: si, item: s };
            e.dataTransfer.setData("application/json", JSON.stringify(payload));
            e.dataTransfer.effectAllowed = "move";
          });
          li.appendChild(chip);
        }

        slotsContainer.appendChild(li);
      }
      // append the wrapped slots container once
      entityItemsEl.appendChild(slotsContainer);
    }

      // Render Abilities
      const abilitiesEl = document.getElementById("entity-abilities-list");
      if (abilitiesEl) {
        abilitiesEl.innerHTML = "";
        // Only town_center entities have spawn ability
        const isTownCenter = (o.kind === "town_center" || (o.meta && o.meta.kind === "town_center"));
        if (isTownCenter) {
          const btn = document.createElement("button");
          btn.textContent = "Spawn Unit (cost: 1 green)";
          btn.style.height = "30px";
          // disable for players who don't own this town center or lack green resources
          const owned = (o.owner && o.owner === mySid);
          const hasGreen = (window.resourceCounts && (window.resourceCounts.green || 0) >= 1);
          btn.disabled = !owned || !hasGreen;
          if (!owned) {
            btn.title = "You do not own this building";
            btn.style.opacity = "0.5";
          } else if (!hasGreen) {
            btn.title = "Requires 1 green resource to spawn";
            btn.style.opacity = "0.5";
          }
          btn.onclick = () => {
            if (!o || !o.id) return;
            if (!owned) return; // double-check on click
            socket.emit("spawn_unit_from_entity", { entityId: o.id });
          };
          abilitiesEl.appendChild(btn);
        }

        // Mine production ability: dropdown + 30s timer
        const isMine = (o.kind === "mine");
        if (isMine) {
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.gap = "8px";
          wrap.style.alignItems = "center";

          const owned = !!o.owner && o.owner === mySid;

          const label = document.createElement("div");
          label.textContent = "Mine:";
          wrap.appendChild(label);

          const select = document.createElement("select");
          ["red","green","blue"].forEach(t => {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t.charAt(0).toUpperCase() + t.slice(1);
            select.appendChild(opt);
          });
          const current = (o.meta && o.meta.mine && o.meta.mine.resource) ? o.meta.mine.resource : "red";
          select.value = current;
          if (!owned) {
            select.disabled = true;
            select.title = "Only the owner can change the resource";
          }
          select.onchange = () => {
            if (!owned) return;
            const sel = select.value;
            // Preserve all existing meta when updating just the resource type
            const updated = mapObjects.find(x => x.id === o.id);
            if (updated && updated.meta && updated.meta.mine) {
              updated.meta.mine.resource = sel;
              socket.emit("update_map_object", { id: o.id, meta: updated.meta });
            } else {
              // Fallback if meta not found
              socket.emit("update_map_object", { id: o.id, meta: { mine: { resource: sel } } });
            }
          };
          wrap.appendChild(select);

          const timerEl = document.createElement("div");
          wrap.appendChild(timerEl);

          // Function to update timer display
          const updateMineTimer = () => {
            // Re-fetch from mapObjects to ensure fresh nextTick
            const current = mapObjects.find(x => x.id === selectedEntityId);
            if (!current || current.kind !== "mine") {
              // Entity deleted or no longer a mine, stop timer
              if (window.__mineCountdownTimer) {
                clearInterval(window.__mineCountdownTimer);
                window.__mineCountdownTimer = null;
              }
              return;
            }
            const nextTick = (current.meta && current.meta.nextTick) ? Number(current.meta.nextTick) : null;
            const now = Date.now() / 1000;
            let rem = (nextTick) ? Math.max(0, Math.ceil(nextTick - now)) : 30;
            timerEl.textContent = `Next in ${rem}s`;
            
            // Debug logs
            if (!window.__mineTimerDebugLog) {
              window.__mineTimerDebugLog = { count: 0 };
            }
            window.__mineTimerDebugLog.count++;
            if (window.__mineTimerDebugLog.count % 5 === 0) {
              console.log(`[MINE_TIMER] ${window.__mineTimerDebugLog.count}: nextTick=${nextTick}, now=${now.toFixed(1)}, rem=${rem}s, resource=${current.meta?.mine?.resource}`);
            }
          };

          // Update immediately, then every 1s
          updateMineTimer();

          // live countdown based on server-provided nextTick
          // Read from mapObjects to get fresh data on each tick, not stale closure
          try { if (window.__mineCountdownTimer) clearInterval(window.__mineCountdownTimer); } catch(e){}
          window.__mineCountdownTimer = setInterval(updateMineTimer, 1000);

          abilitiesEl.appendChild(wrap);
        }
      }

      entityPanelEl.style.display = "block";
  }

  function renderEntityActions(o) {
    entityActionsList.innerHTML = "";
    ensureEntityMeta(o);

    for (let i = 0; i < o.meta.actions.length; i++) {
      const a = o.meta.actions[i];

      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.gap = "4px";
      wrap.style.alignItems = "center";

      const btn = document.createElement("button");
      btn.textContent = a.label || `Action ${i+1}`;
      btn.style.height = "26px";

      // Clicking action in inspector triggers an event (so you can hook gameplay)
      btn.onclick = () => {
        socket.emit("entity_action", { entityId: o.id, actionId: a.id, label: a.label });
        // optional local feedback:
        // console.log("entity_action", o.id, a);
      };

      const del = document.createElement("button");
      del.textContent = "✕";
      del.style.height = "26px";
      del.onclick = () => {
        o.meta.actions.splice(i, 1);
        renderEntityActions(o);
      };

      wrap.appendChild(btn);
      wrap.appendChild(del);
      entityActionsList.appendChild(wrap);
    }
  }
  entityAddActionBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    // If tile + editor off => no edits
    if (o.type === "tile" && !editorMode) return;

    ensureEntityMeta(o);

    const label = prompt("Action label?", "Inspect");
    if (!label) return;

    o.meta.actions.push({ id: crypto.randomUUID(), label });
    renderEntityActions(o);
  };


  entitySaveBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    if (o.type === "tile" && !editorMode) return;

    ensureEntityMeta(o);
    o.meta.title = entityTitleInput.value || "";
    o.meta.bio = entityBioInput.value || "";
    socket.emit("update_map_object", { id: o.id, meta: o.meta });
    entityPanelEl.style.display = "none";
  };

  entityDeleteBtn.onclick = () => {
    if (!selectedEntityId) return;
    const o = mapObjects.find(x => x.id === selectedEntityId);
    if (!o) return;

    if (o.type === "tile" && !editorMode) return;

    socket.emit("delete_map_object", { id: selectedEntityId });
    entityPanelEl.style.display = "none";
    selectedEntityId = null;
  };




  const playerSprites = {
    idle: {},
    walk: {},
    idleshadow:{},
    walkshadow:{},
  };

  function pad(num, length=3) { return num.toString().padStart(length, "0"); }
  function padFrame(num, length=4) { return num.toString().padStart(length, "0"); }



  for (const deg of DIRECTIONS) {
    const d = pad(deg);

    playerSprites.idle[d] = [];
    playerSprites.walk[d] = [];
    playerSprites.idleshadow[d] = [];
    playerSprites.walkshadow[d] = [];

    // Idle frames
    for (let i = 1; i <= IDLE_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Idle/Body/${d}/Idle_Body_${d}_${padFrame(i)}.png`;
      playerSprites.idle[d].push(img);
      const imgshadow = new Image();
      imgshadow.src = `static/Idle/Shadow/${d}/Idle_Shadow_${d}_${padFrame(i)}.png`;
      playerSprites.idleshadow[d].push(imgshadow);
    }

    // Walk frames
    for (let i = 1; i <= WALK_FRAMES; i++) {
      const img = new Image();
      img.src = `static/Run/Body/${d}/Run_Body_${d}_${padFrame(i)}.png`;
      playerSprites.walk[d].push(img);
      const imgshadow = new Image();
      imgshadow.src = `static/Run/Shadow/${d}/Run_Shadow_${d}_${padFrame(i)}.png`;
      playerSprites.walkshadow[d].push(imgshadow);
    }
  }

  // Inside playerSprites
  playerSprites.attack = {};
  playerSprites.attackshadow = {};
  for(const deg of DIRECTIONS){
      const d = pad(deg);
      playerSprites.attack[d] = [];
      playerSprites.attackshadow[d] = [];
      for(let i=1;i<=ATTACK_ANIM_FRAMES;i++){
          const img = new Image();
          img.src = `static/Attack/Body/${d}/Attack1_Body_${d}_${padFrame(i)}.png`;
          playerSprites.attack[d].push(img);

          const imgShadow = new Image();
          imgShadow.src = `static/Attack/Shadow/${d}/Attack1_Shadow_${d}_${padFrame(i)}.png`;
          playerSprites.attackshadow[d].push(imgShadow);
      }
  }







  /* ================= LOCAL UNITS ================= */
  // `myUnits` is declared in the globals block at the top; do not re-declare.


  for(const u of myUnits){
      u.hp = 100;           // max health
      u.targetEnemy = null;  // {sid, unitIndex} or null
      u.attackCooldown = 0;  // ms cooldown for attack ticks
      u.attackFrame = 0;     // animation frame 0-23
      u.manualMove = false; // true if user right-clicked to move
  }






  function getDirection(dx, dy) {
    const angle = Math.atan2(dy, dx); // -PI to PI
    let dir = Math.round((angle / (2 * Math.PI)) * DIRECTIONS);
    if (dir < 0) dir += DIRECTIONS;
    return dir % DIRECTIONS;
  }

  // `players` and `buildings` are declared in the globals block at the top; do not re-declare.







  /* ================= TILE ================= */
  const tile = new Image();
  tile.src = "static/grassbackground.png";
  const TILE_W = 5178;
  const TILE_H = 3009;
  const HALF_W = TILE_W/2.1;
  const HALF_H = TILE_H/2.1;


  const treeImg = new Image();
  treeImg.src = "static/tree.png";

  // Adjust to your sprite size
  const TREE_W = 250;
  const TREE_H = 250;

  // Trees will come from server

  socket.on("server_trees", serverTrees => {
      trees = serverTrees;
  });

  socket.connect();



  const COLLISION_STEP = 8;
  const COLLISION_MIN = 8;
  const COLLISION_MAX = 512;


  function mergeUnitsPreserveFrames(localUnits, serverUnits) {
    const byId = new Map(localUnits.map(u => [u.id, u]));
    const merged = [];

    for (const su0 of (serverUnits || [])) {
      const existing = byId.get(su0.id);
      const su = {
        ...su0,
        anim: su0.anim || "idle",
        dir: String(su0.dir ?? "000").padStart(3,"0"),
        hp: (su0.hp ?? existing?.hp ?? UNIT_MAX_HEALTH),
        tx:   (su0.tx ?? su0.x),
        ty:   (su0.ty ?? su0.y),
      };

      let lu = byId.get(su.id);
  if (!lu) {
    lu = {
      ...su,
      frame: 0,
      attackFrame: 0,
      renderFrame: 0,
      renderAttackFrame: 0,
      lastX: su.x,
      lastY: su.y,
      selected: false,
      manualMove: false,

      // ✅ ADD THESE
      targetEnemy: null,
      attackCooldown: ATTACK_COOLDOWN, // allow immediate attack
      harvesting: null,
    };
  } else {
        // update authoritative fields
        lu.x = su.x; lu.y = su.y;
        lu.tx = su.tx; lu.ty = su.ty;
        lu.hp = su.hp;
        lu.dir = su.dir;

        if (lu.anim !== su.anim) {
          lu.anim = su.anim;
          lu.frame = 0;
          lu.attackFrame = 0;
          lu.renderFrame = 0;
          lu.renderAttackFrame = 0;
        }
      }
      merged.push(lu);
    }

    return merged;
  }



  /* ================= RESOURCES ================= */
  const RESOURCE_RADIUS = 40;
  const HARVEST_TIME = 10000; // ms

  const RESOURCE_STOP_RADIUS    = PLAYER_RADIUS + RESOURCE_RADIUS_COLLIDE + 1; // 36
  const RESOURCE_HARVEST_RADIUS = RESOURCE_STOP_RADIUS + 4;                    // 40



  resources = resources || [];          // {id, x, y}
  const resourceImg = new Image();
  resourceImg.src = "static/resource.png";
  const RES_W = 48;
  const RES_H = 48;

  resourceCounts = resourceCounts || { red: 0, green: 0, blue: 0 };
  hoveredResource = hoveredResource || null;

  hoveredPlayerSid = hoveredPlayerSid || null;  

  function spawnResources(){
    const cols = 69;
    const rows = 53;
    const spacing = 180;

    // start ids after any existing resources to avoid collisions
    let nextId = 0;
    if (resources && resources.length) {
      nextId = Math.max(...resources.map(rr => rr.id || 0)) + 1;
    }

    // center the grid so resources appear in both negative and positive world coordinates
    const colOffset = Math.floor(cols / 2);
    const rowOffset = Math.floor(rows / 2);

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (Math.random() < 0.6) {
          const types = ["red", "green", "blue"];
          const t = types[Math.floor(Math.random() * types.length)];

          const cc = c - colOffset;
          const rr = r - rowOffset;

          resources.push({
            id: nextId++,
            x: (cc - rr) * spacing,
            y: (cc + rr) * spacing / 2,
            type: t
          });
        }
      }
    }
  }

  /* ================= COMBAT ================= */
  const ATTACK_RANGE = 80;
  const DPS = 10; // damage per second

  let targetPlayerSid = null;

  let playerHealth = {};
  const MAX_HEALTH = 100;

  /* ================= SOCKET STATE ================= */
  // Keep player positions/colors from state
  // Update remote units

  socket.on("state", (state) => {
    console.log("STATE: before merge myUnits", myUnits.length,
              "server me.units", state.players?.[mySid]?.units?.length);

    if (state.ground_items) groundItems = state.ground_items;
    // sync authoritative resources from server
    if (state.resources) {
      resources = state.resources;
    }
    // sync map objects (for mine production timer updates)
    if (state.map_objects) {
      mapObjects = state.map_objects;
      // refresh entity inspector if open (to get updated nextTick)
      if (selectedEntityId) {
        const updated = mapObjects.find(x => x.id === selectedEntityId);
        if (updated && entityPanelEl && entityPanelEl.style.display === "block") {
          openEntityInspector(updated);
        }
      }
    }

    // ✅ FIRST: sync my own units from server (adopt server ids)
    const me = state.players?.[mySid];
    if (me && Array.isArray(me.units)) {
      myUnits = mergeUnitsPreserveFrames(myUnits, me.units);
    }
    // sync authoritative resource counts from server
    if (me) {
      resourceCounts = me.resources || { red: 0, green: 0, blue: 0 };
      window.resourceCounts = resourceCounts;
    }
    try { updateBuildButton(); updateMineButton(); } catch (e) {}

    for (const sid in players){
            const first = players[sid].units[0];
    if (first) { players[sid].x = first.x; players[sid].y = first.y; }
    }
    
    // existing: remove players no longer on server (but keep players that exist even if they currently have 0 units)
    for (const sid in players) {
      if (!state.players[sid]) {
        delete players[sid];
      }
    }

    // ✅ sync other players as you already do (but keep them even if units array is empty)
    for (const sid in state.players) {
      if (sid === mySid) continue;
      const sp = state.players[sid];

      if (!players[sid]) players[sid] = { x: 0, y: 0, color: "#fff", units: [] };

      players[sid].x = sp.x;
      players[sid].y = sp.y;
      players[sid].color = sp.color;

      const serverUnits = Array.isArray(sp.units) ? sp.units : [];
      players[sid].units = mergeUnitsPreserveFrames(players[sid].units || [], serverUnits);
    }

    // buildings...
    buildings = state.buildings.map(sb => {
      const existing = buildings.find(b => b.x === sb.x && b.y === sb.y && b.owner === sb.owner);
      return {
        ...sb,
        selected: existing ? existing.selected : false,
        queue: existing ? existing.queue : []
      };
    });

    groundItems = state.ground_items || [];
  });

      

  socket.on("unit_hp_update", ({ sid, unitId, hp }) => {
      const list = sid === mySid ? myUnits : players[sid]?.units;
      if (!list) return;
      const u = list.find(u => u.id === unitId);
      if (!u) return;

      u.hp = hp;

      if (u.hp <= 0) {
          // remove locally
          const i = list.indexOf(u);
          if (i !== -1) list.splice(i, 1);
      }
  });

  socket.on("ground_items", (items) => {
    groundItems = items || [];
    // optional debug:
    // console.log("ground_items update", groundItems.length);
  });

  // also listen for direct resources broadcast
  socket.on("resources", (res) => {
    resources = res || [];
  });

  socket.on("update_units", ({ sid, units }) => {
    if (sid === mySid) return;

    // ✅ if server says this player has no units, remove them immediately
    if (!units || units.length === 0) {
      delete players[sid];
      return;
    }

    if (!players[sid]) players[sid] = { x:0, y:0, color:"#fff", units: [] };

    players[sid].units = mergeUnitsPreserveFrames(players[sid].units || [], units);

    // keep hover point synced
    const first = players[sid].units[0];
    if (first) {
      players[sid].x = first.x;
      players[sid].y = first.y;
    }
  });


  let selectedUnits = []; // Array of selected unit IDs
  let allUnits = {}; // sid -> units list (updated from server)

  // Function to render selected units in panel
  function renderUnitPanel() {
      const unitListDiv = document.getElementById("unit-list");
      unitListDiv.innerHTML = ""; // clear

      selectedUnits.forEach(uid => {
          let unit = findUnitById(uid);
          if (!unit) return;

          const unitDiv = document.createElement("div");
          unitDiv.textContent = `Unit ${unit.id.slice(0,4)}`; // show short id
          unitDiv.style.cursor = "pointer";
          unitDiv.style.marginBottom = "5px";
          unitDiv.style.padding = "2px 5px";
          unitDiv.style.border = "1px solid white";
          unitDiv.style.borderRadius = "4px";
          unitDiv.addEventListener("click", () => {
              renderUnitItems(unit);
          });
          unitListDiv.appendChild(unitDiv);
      });
  }

  function findUnitById(uid) {
      // Prefer local units (they definitely have items)
      const local = myUnits.find(u => u.id === uid);
      if (local) return local;

      for (let sid in allUnits) {
          const unit = (allUnits[sid] || []).find(u => u.id === uid);
          if (unit) return unit;
      }
      return null;
  }


  socket.on("unit_slots_update", ({ unitId, itemSlots }) => {
    const u = myUnits.find(x => x.id === unitId);
    if (!u) return;

    u.itemSlots = itemSlots;

    // refresh UI if currently showing this unit
    if (currentItemsUnitId === unitId) renderUnitItems(u);
  });


  let mapObjects = []; // persistent objects from server

  socket.on("map_objects", (objs) => {
    mapObjects = objs || [];
    // If entity inspector is open for an entity, refresh it immediately
    if (selectedEntityId) {
      const updated = mapObjects.find(x => x.id === selectedEntityId);
      if (updated && entityPanelEl && entityPanelEl.style.display === "block") {
        openEntityInspector(updated);
      }
    }
    // update build button count/limit
    try { updateBuildButton(); updateMineButton(); } catch(e){}
  });

  // Update entity HP when server reports damage
  socket.on("entity_hp_update", ({ entityId, hp }) => {
    try {
      const o = (mapObjects || []).find(x => x.id === entityId);
      if (o) {
        o.hp = hp;
        // refresh inspector if open for this entity
        if (selectedEntityId === entityId && entityPanelEl && entityPanelEl.style.display === 'block') {
          openEntityInspector(o);
        }
      }
      console.log("SERVER_DEBUG: entity_hp_update", entityId, hp);
    } catch (e) { console.error(e); }
  });

  tile.onload = draw;
  
  // Start the animation loop once assets are loaded
  (function startDraw() {
    if (window.ASSETS_LOADED) {
      draw();
    } else {
      requestAnimationFrame(startDraw);
    }
  })();
  </script>
  </body>
  </html>