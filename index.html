<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Isometric Multiplayer RTS</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:black; }
canvas { display:block; }
#hud {
  position:fixed;
  top:10px; left:10px;
  color:white;
  font-family:monospace;
  background:rgba(0,0,0,0.5);
  padding:6px;
}
#panel {
  position:fixed;
  bottom:20px;
  left:20px;
  width:220px;
  height:120px;
  background:rgba(30,30,30,0.85);
  border:2px solid #888;
  padding:10px;
  color:white;
  font-family:monospace;
  display:none;
}

#buildBtn {
  width:100%;
  height:40px;
  margin-top:10px;
  background:#444;
  color:white;
  border:1px solid #aaa;
  cursor:pointer;
}
#buildBtn:hover { background:#666; }
#buildBtn:disabled { background:#222; color:#777; cursor:not-allowed; }
</style>
</head>

<body>
<canvas id="game"></canvas>
<div id="hud"></div>

<div id="panel">
  <div>Unit Selected</div>
  <button id="buildBtn">Place Building</button>
</div>

<div id="buildingPanel" style="display:none; position:fixed; bottom:20px; left:20px; width:220px; height:120px; background:rgba(30,30,30,0.85); border:2px solid #888; padding:10px; color:white; font-family:monospace;">
  <div>Building Selected</div>
  <button id="createUnitBtn">Create Unit</button>
</div>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");
const panel = document.getElementById("panel");
const buildBtn = document.getElementById("buildBtn");
const socket = io();

let mySid = null;
socket.on("connect", ()=> mySid = socket.id);

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

let DEBUG_COLLISIONS = true; // toggle on/off

function drawCircleDebug(x, y, r, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.stroke();
}

function drawRectDebug(x, y, w, h, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
}


/* ================= CAMERA ================= */
let camera = {x:0,y:0};
const camSpeed = 12;
const keys = {};
document.addEventListener("keydown", e=>keys[e.key]=true);
document.addEventListener("keyup", e=>keys[e.key]=false);


/* ================= PLAYER SPRITES ================= */

const SPRITE_W = 256;
const SPRITE_H = 256;
const DIRECTIONS = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337];
const IDLE_FRAMES = 24;
const WALK_FRAMES = 24;
const ANIM_SPEED = 0.3;


const UNIT_RADIUS = 18;
const PLAYER_RADIUS = 20;
const TREE_RADIUS = 140;
const RESOURCE_RADIUS_COLLIDE = 28;

// Buildings use rectangle collision
const BUILD_COLLISION_PADDING = -50;


const UNIT_ATTACK_RANGE = PLAYER_RADIUS + UNIT_RADIUS + 10; // 10 extra for buffer
const UNIT_ATTACK_DPS = 30; // damage per second
const ATTACK_COOLDOWN = 1000 / 60; // 1 tick per frame (60fps)
const UNIT_MAX_HEALTH = 100;
const ATTACK_ANIM_FRAMES = 24;


const playerSprites = {
  idle: {},
  walk: {},
  idleshadow:{},
  walkshadow:{},
};

function pad(num, length=3) { return num.toString().padStart(length, "0"); }
function padFrame(num, length=4) { return num.toString().padStart(length, "0"); }



for (const deg of DIRECTIONS) {
  const d = pad(deg);

  playerSprites.idle[d] = [];
  playerSprites.walk[d] = [];
  playerSprites.idleshadow[d] = [];
  playerSprites.walkshadow[d] = [];

  // Idle frames
  for (let i = 1; i <= IDLE_FRAMES; i++) {
    const img = new Image();
    img.src = `static/Idle/Body/${d}/Idle_Body_${d}_${padFrame(i)}.png`;
    playerSprites.idle[d].push(img);
    const imgshadow = new Image();
    imgshadow.src = `static/Idle/Shadow/${d}/Idle_Shadow_${d}_${padFrame(i)}.png`;
    playerSprites.idleshadow[d].push(imgshadow);
  }

  // Walk frames
  for (let i = 1; i <= WALK_FRAMES; i++) {
    const img = new Image();
    img.src = `static/Run/Body/${d}/Run_Body_${d}_${padFrame(i)}.png`;
    playerSprites.walk[d].push(img);
    const imgshadow = new Image();
    imgshadow.src = `static/Run/Shadow/${d}/Run_Shadow_${d}_${padFrame(i)}.png`;
    playerSprites.walkshadow[d].push(imgshadow);
  }
}

// Inside playerSprites
playerSprites.attack = {};
playerSprites.attackshadow = {};
for(const deg of DIRECTIONS){
    const d = pad(deg);
    playerSprites.attack[d] = [];
    playerSprites.attackshadow[d] = [];
    for(let i=1;i<=ATTACK_ANIM_FRAMES;i++){
        const img = new Image();
        img.src = `static/Attack/Body/${d}/Attack1_Body_${d}_${padFrame(i)}.png`;
        playerSprites.attack[d].push(img);

        const imgShadow = new Image();
        imgShadow.src = `static/Attack/Shadow/${d}/Attack1_Shadow_${d}_${padFrame(i)}.png`;
        playerSprites.attackshadow[d].push(imgShadow);
    }
}





function getDirKey(dx, dy) {
    // invert dy because screen Y increases down but 000 is north
    const angle = ((Math.atan2(dy, dx) * 180 / Math.PI + 90) % 360);

    const dirs = [0,22,45,67,90,112,135,157,180,202,225,247,270,292,315,337];
    let closest = dirs[0];
    let minDiff = 360;

    for(const d of dirs){
        let diff = Math.abs(d - angle);
        diff = Math.min(diff, 360 - diff);
        if(diff < minDiff){
            minDiff = diff;
            closest = d;
        }
    }

    return closest.toString().padStart(3,"0");
}




/* ================= LOCAL UNITS ================= */
let myUnits = [
  {
    x: 0, y: 0,
    tx: 0, ty: 0,
    selected: false,
    targetResource: null,
    anim: "idle",
    frame: 0,
    dir: "000", // â† use string here
    lastX: 0,
    lastY: 0
  }
];

for(const u of myUnits){
    u.hp = 100;           // max health
    u.targetEnemy = null;  // {sid, unitIndex} or null
    u.attackCooldown = 0;  // ms cooldown for attack ticks
    u.attackFrame = 0;     // animation frame 0-23
    u.manualMove = false; // true if user right-clicked to move
}



function findNearestEnemy(u) {
    let nearest = null;
    let nearestDist = Infinity;

    // Check other players' units
    for(const sid in players){
        if(sid === mySid) continue;
        const p = players[sid];
        p.units.forEach((eu, idx) => {
            if(eu.hp <= 0) return;
            const dist = Math.hypot(u.x - eu.x, u.y - eu.y);
            if(dist < nearestDist){
                nearestDist = dist;
                nearest = {sid, idx, x: eu.x, y: eu.y};
            }
        });
    }

    return nearest;
}


function getDirection(dx, dy) {
  const angle = Math.atan2(dy, dx); // -PI to PI
  let dir = Math.round((angle / (2 * Math.PI)) * DIRECTIONS);
  if (dir < 0) dir += DIRECTIONS;
  return dir % DIRECTIONS;
}

let players = {};
let buildings = []; // list of {x, y, owner}







/* ================= TILE ================= */
const tile = new Image();
tile.src = "static/grassbackground.png";
const TILE_W = 5178;
const TILE_H = 3009;
const HALF_W = TILE_W/2.1;
const HALF_H = TILE_H/2.1;


const treeImg = new Image();
treeImg.src = "static/tree.png";

// Adjust to your sprite size
const TREE_W = 250;
const TREE_H = 250;

// Trees will come from server
let trees = []; // [{x,y},...]

socket.on("server_trees", serverTrees => {
    trees = serverTrees;
});



/* ================= RESOURCES ================= */
const RESOURCE_RADIUS = 40;
const HARVEST_TIME = 10000; // ms

let resources = [];          // {id, x, y}
let harvesting = null;       // {resourceId, startTime}
const resourceImg = new Image();
resourceImg.src = "static/resource.png";
const RES_W = 48;
const RES_H = 48;

let resourceCount = 0;
let hoveredResource = null;

let hoveredPlayerSid = null;  

function spawnResources(){
  const cols = 69;
  const rows = 53;
  const spacing = 180;
  let id = 0;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(Math.random() < 0.035){
        resources.push({
          id: id++,
          x: (c - r) * spacing,
          y: (c + r) * spacing / 2
        });
      }
    }
  }
}
spawnResources();

function resolveCircleCircle(a, ar, b, br) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.hypot(dx, dy);
    const minDist = ar + br;

    // ---------- DEBUG DRAW ----------
    if (DEBUG_COLLISIONS) {
        const ax = canvas.width/2 + a.x - camera.x;
        const ay = canvas.height/2 + a.y - camera.y;
        const bx = canvas.width/2 + b.x - camera.x;
        const by = canvas.height/2 + b.y - camera.y;

        ctx.strokeStyle = "rgba(0,255,255,0.4)";
        ctx.beginPath();
        ctx.arc(ax, ay, ar, 0, Math.PI*2);
        ctx.stroke();

        ctx.strokeStyle = "rgba(255,0,0,0.4)";
        ctx.beginPath();
        ctx.arc(bx, by, br, 0, Math.PI*2);
        ctx.stroke();
    }
    // ------------------------------

    if (dist === 0 || dist >= minDist) return;

    const overlap = minDist - dist;
    const nx = dx / dist;
    const ny = dy / dist;

    // Apply push
    a.x += nx * overlap;
    a.y += ny * overlap;

    // ---------- DEBUG PENETRATION ----------
    if (DEBUG_COLLISIONS) {
        const ax = canvas.width/2 + a.x - camera.x;
        const ay = canvas.height/2 + a.y - camera.y;

        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + nx * overlap, ay + ny * overlap);
        ctx.stroke();
    }
}

function resolveCircleRect(unit, radius, rect) {
    const left   = rect.x - BUILD_W/2 - BUILD_COLLISION_PADDING;
    const right  = rect.x + BUILD_W/2 + BUILD_COLLISION_PADDING;
    const top    = rect.y - BUILD_H/2 - BUILD_COLLISION_PADDING;
    const bottom = rect.y + BUILD_H/2 + BUILD_COLLISION_PADDING;

    const closestX = Math.max(left, Math.min(unit.x, right));
    const closestY = Math.max(top, Math.min(unit.y, bottom));

    const dx = unit.x - closestX;
    const dy = unit.y - closestY;
    const dist = Math.hypot(dx, dy);

    // ---------- DEBUG DRAW ----------
    if (DEBUG_COLLISIONS) {
        const ux = canvas.width/2 + unit.x - camera.x;
        const uy = canvas.height/2 + unit.y - camera.y;

        ctx.strokeStyle = "rgba(255,0,0,0.4)";
        ctx.strokeRect(canvas.width/2 + left - camera.x, canvas.height/2 + top - camera.y, right-left, bottom-top);

        ctx.strokeStyle = "rgba(0,255,255,0.4)";
        ctx.beginPath();
        ctx.arc(ux, uy, radius, 0, Math.PI*2);
        ctx.stroke();
    }
    // ------------------------------

    if (dist === 0 || dist >= radius) return;

    const overlap = radius - dist;
    const nx = dx / dist;
    const ny = dy / dist;

    // Apply push
    unit.x += nx * overlap;
    unit.y += ny * overlap;

    // ---------- DEBUG PENETRATION ----------
    if (DEBUG_COLLISIONS) {
        const ux = canvas.width/2 + unit.x - camera.x;
        const uy = canvas.height/2 + unit.y - camera.y;

        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(ux, uy);
        ctx.lineTo(ux + nx * overlap, uy + ny * overlap);
        ctx.stroke();
    }
}

function applyCollisions(u) {
    // Trees
    for (const t of trees) resolveCircleCircle(u, PLAYER_RADIUS, {x: t.x, y: t.y-150}, TREE_RADIUS);

    // Resources
    for (const r of resources) resolveCircleCircle(u, PLAYER_RADIUS, {x: r.x, y: r.y}, RESOURCE_RADIUS_COLLIDE);

    // Buildings
    for (const b of buildings) resolveCircleRect(u, PLAYER_RADIUS, b);

    // Other local units
    for (const other of myUnits) {
        if (other === u) continue;
        resolveCircleCircle(u, UNIT_RADIUS, other, UNIT_RADIUS);
    }

    // Other players' units
    for (const sid in players) {
        if (sid === mySid) continue;
        for (const opUnit of players[sid].units) {
            resolveCircleCircle(u, PLAYER_RADIUS, opUnit, UNIT_RADIUS);
        }
    }

    // Optional: other players as a single "main unit" collision
    // for (const sid in players) {
    //     if (sid === mySid) continue;
    //     const op = players[sid];
    //     resolveCircleCircle(u, PLAYER_RADIUS, {x: op.x, y: op.y}, PLAYER_RADIUS);
    // }
}



/* ================= RTS INPUT ================= */
let selecting=false;
let selectStart={x:0,y:0};
let mouse={x:0,y:0};
let buildMode=false;
let localBuildingPlaced=false;

canvas.addEventListener("mousemove", e=>{
  mouse.x = e.clientX;
  mouse.y = e.clientY;

  const wx = camera.x + mouse.x - canvas.width/2;
  const wy = camera.y + mouse.y - canvas.height/2;

  hoveredResource = null;
  hoveredPlayerSid = null;

  // Resource hover (priority 1)
  for(const r of resources){
    if(Math.hypot(r.x-wx, r.y-wy) < RESOURCE_RADIUS){
      hoveredResource = r;
      canvas.style.cursor = "pointer";
      return;
    }
  }

  // Player hover (priority 2)
  for(const sid in players){
    if(sid === mySid) continue;
    const p = players[sid];
    if(Math.hypot(p.x-wx, p.y-wy) < 20){
      hoveredPlayerSid = sid;
      canvas.style.cursor = "crosshair";
      return;
    }
  }

  canvas.style.cursor = "default";
});



canvas.addEventListener("mousedown", e => {
  const wx = camera.x + mouse.x - canvas.width / 2;
  const wy = camera.y + mouse.y - canvas.height / 2;

  if (e.button === 0) { // left click

    // ===== Build placement =====
  if (buildMode && !localBuildingPlaced) {
    const newBuilding = { x: wx, y: wy, owner: mySid, selected: true, queue: [] };
    buildings.push(newBuilding);
    localBuildingPlaced = true;
    buildMode = false;
    buildBtn.disabled = true;
    socket.emit("place_building", { x: wx, y: wy });
    return;
  }

    // ===== Check for building click =====
    let clickedBuilding = null;
    for (const b of buildings) {
      const bx = canvas.width / 2 + b.x - camera.x;
      const by = canvas.height / 2 + b.y - camera.y;
      const dx = Math.abs(mouse.x - bx);
      const dy = Math.abs(mouse.y - by);
      if (dx < BUILD_W / 2 && dy < BUILD_H / 2) {
        clickedBuilding = b;
        break;
      }
    }

    if (clickedBuilding && clickedBuilding.owner === mySid) {
      buildings.forEach(b => b.selected = false);
      clickedBuilding.selected = true;
      buildingPanel.style.display = "block";
      panel.style.display = "none";
      selecting = false;
      return;
    }

    // ===== Check for unit click =====
    let clickedUnit = null;
    for (const u of myUnits) {
      const ux = canvas.width / 2 + u.x - camera.x;
      const uy = canvas.height / 2 + u.y - camera.y;
      if (Math.hypot(mouse.x - ux, mouse.y - uy) < 20) {
        clickedUnit = u;
        break;
      }
    }

    if (clickedUnit) {
      myUnits.forEach(u => u.selected = false);
      clickedUnit.selected = true;
      selecting = false;
      return;
    }

    // ===== Clicked empty space =====
    buildings.forEach(b => b.selected = false);
    buildingPanel.style.display = "none";
    myUnits.forEach(u => u.selected = false);

    // Start selection box
    selecting = true;
    selectStart.x = mouse.x;
    selectStart.y = mouse.y;
  }
});






canvas.addEventListener("mouseup", e=>{
  if(e.button===0){
    selecting=false;
    const x1=Math.min(selectStart.x,mouse.x);
    const y1=Math.min(selectStart.y,mouse.y);
    const x2=Math.max(selectStart.x,mouse.x);
    const y2=Math.max(selectStart.y,mouse.y);
    for(const u of myUnits){
      const sx=canvas.width/2+u.x-camera.x;
      const sy=canvas.height/2+u.y-camera.y;
      u.selected=(sx>=x1&&sx<=x2 && sy>=y1&&sy<=y2);
    }
  } 
      if(e.button === 2){ // right click
        const wx = camera.x + mouse.x - canvas.width/2;
        const wy = camera.y + mouse.y - canvas.height/2;

        let clickedResource = null;
        let clickedPlayerSid = null;

        for(const r of resources){
            if(Math.hypot(r.x-wx,r.y-wy) < RESOURCE_RADIUS){
                clickedResource = r;
                break;
            }
        }

        if(!clickedResource){
            for(const sid in players){
                if(sid === mySid) continue;
                const p = players[sid];
                if(Math.hypot(p.x-wx,p.y-wy) < 20){
                    clickedPlayerSid = sid;
                    break;
                }
            }
        }

        const selectedUnits = myUnits.filter(u => u.selected);

        selectedUnits.forEach(u => {
            u.targetResource = clickedResource ? clickedResource.id : null;
            u.targetEnemy = null;          // stop attacking
            u.tx = wx;
            u.ty = wy;
            u.manualMove = true;           // allow movement to override combat
            harvesting = null;
        });
    }
});

canvas.addEventListener("contextmenu", e=>e.preventDefault());

const createUnitBtn = document.getElementById("createUnitBtn");
createUnitBtn.onclick = () => {
    const selectedBuilding = buildings.find(b => b.selected && b.owner === mySid);
    if (!selectedBuilding) return;

    const radius = BUILD_W / 2 + 30; // spawn outside building
    const unitsToSpawn = 1; // you can increase this if creating multiple units at once

    // Count how many units are already around this building
    const existingUnits = myUnits.filter(u => Math.hypot(u.x - selectedBuilding.x, u.y - selectedBuilding.y) < radius + 20);
    const startIndex = existingUnits.length;

    for (let i = 0; i < unitsToSpawn; i++) {
        const idx = startIndex + i;
        const angle = (idx * 45) * Math.PI / 180; // spread units 45Â° apart
        const spawnX = selectedBuilding.x + Math.cos(angle) * radius;
        const spawnY = selectedBuilding.y + Math.sin(angle) * radius;

const newUnit = {
    x: spawnX,
    y: spawnY,
    tx: spawnX,
    ty: spawnY,
    selected: false,
    targetResource: null,
    targetEnemy: null,
    anim: "idle",
    frame: 0,
    attackFrame: 0,
    dir: "000",
    hp: UNIT_MAX_HEALTH,
    attackCooldown: 0,
    manualMove: false,
    lastX: spawnX,
    lastY: spawnY
};
myUnits.push(newUnit);
socket.emit("spawn_unit", { unit: newUnit });

    }
};



buildBtn.onclick = ()=>{ if(!localBuildingPlaced) buildMode=true; };

/* ================= COMBAT ================= */
const ATTACK_RANGE = 80;
const DPS = 10; // damage per second

let targetPlayerSid = null;

let playerHealth = {};
const MAX_HEALTH = 100;

/* ================= SOCKET STATE ================= */
// Keep player positions/colors from state
// Update remote units
socket.on("state", state => {
    console.log(state)
    for (const sid in players) {
      if (!state.players[sid]) {
        delete players[sid];
      }
    }
    for(const sid in state.players){
        if(sid === mySid) continue;
        if(!players[sid]) players[sid] = {x:0,y:0,color:"#fff",units:[]};
        players[sid].x = state.players[sid].x;
        players[sid].y = state.players[sid].y;
        players[sid].color = state.players[sid].color;
        players[sid].units = state.players[sid].units || [];
    }
    buildings = state.buildings.map(sb => {
      // Try to find an existing local building
      const existing = buildings.find(b =>
        b.x === sb.x &&
        b.y === sb.y &&
        b.owner === sb.owner
      );

      return {
        ...sb,
        selected: existing ? existing.selected : false,
        queue: existing ? existing.queue : []
      };
    });
});


socket.on("update_units", data => {
    const sid = data.sid;
    if(sid === mySid) return;

    if(!players[sid]) players[sid] = {x:0, y:0, color:"#fff", units:[]};

const serverUnits = data.units || [];
for (let i = 0; i < serverUnits.length; i++) {
    const su = serverUnits[i];
    if (!players[sid].units[i]) {
        players[sid].units[i] = { ...su };
    } else {
        const lu = players[sid].units[i];
        lu.x = su.x;
        lu.y = su.y;
        lu.anim = su.anim ?? lu.anim;           // keep local attack anim if running
        lu.attackFrame = su.attackFrame ?? lu.attackFrame;
        lu.dir = su.dir ?? lu.dir;
    }
}

});







/* ================= UPDATE ================= */
function update(){
  // ===== CAMERA =====
  if(keys.w) camera.y-=camSpeed;
  if(keys.s) camera.y+=camSpeed;
  if(keys.a) camera.x-=camSpeed;
  if(keys.d) camera.x+=camSpeed;

  // ===== UNIT MOVEMENT =====
  const MANUAL_MOVE_SPEED = 4.5;   // right-click speed
  const ENEMY_CHASE_SPEED = 2.5;   // slower than manual
  const DEADZONE = 1.5;
  const STOP_CHASE_DISTANCE = 200;
  const COMBAT_AGGRO_RADIUS = 200;

  for (let i = myUnits.length - 1; i >= 0; i--) {
      const u = myUnits[i];

      if (u.hp <= 0) {
          myUnits.splice(i, 1); // Remove dead units
          continue; // Skip further updates for this unit
      }

      // --- Manual movement takes priority ---
if(u.manualMove){
    const dx = u.tx - u.x;
    const dy = u.ty - u.y;
    const dist = Math.hypot(dx, dy);

    if(dist > DEADZONE){
        u.x += (dx / dist) * Math.min(MANUAL_MOVE_SPEED, dist);
        u.y += (dy / dist) * Math.min(MANUAL_MOVE_SPEED, dist);
        u.anim = "walk";
        u.dir = getDirKey(dx, dy);

        // âœ… Advance animation frame
        u.frame += ANIM_SPEED;
        if(u.frame >= WALK_FRAMES) u.frame = 0;
    } else {
        u.x = u.tx;
        u.y = u.ty;
        u.manualMove = false;
        u.anim = "idle";
        u.frame += ANIM_SPEED;
        if(u.frame >= IDLE_FRAMES) u.frame = 0;
    }

    continue; // skip combat while moving manually
}

      // --- Harvesting resources ---
      if(u.targetResource !== null){
          const r = resources.find(r=>r.id===u.targetResource);
          if(r){
              const dist = Math.hypot(u.x - r.x, u.y - r.y);
              if(dist < RESOURCE_RADIUS){
                  if(!harvesting){
                      harvesting = { resourceId: r.id, startTime: performance.now() };
                  } else if(performance.now() - harvesting.startTime >= HARVEST_TIME){
                      resources = resources.filter(rr => rr.id !== r.id);
                      resourceCount++;
                      harvesting = null;
                      u.targetResource = null;
                  }
              } else {
                  harvesting = null;
              }
          } else u.targetResource = null;
      }

      // --- Combat / auto-chase ---
// Combat update
for(const u of myUnits){
    if(u.hp <= 0) continue;
    if(!u.manualMove){
        if(!u.targetEnemy || !players[u.targetEnemy.sid]?.units[u.targetEnemy.idx] || players[u.targetEnemy.sid].units[u.targetEnemy.idx].hp <= 0){
            u.targetEnemy = null;
        }

        if(!u.targetEnemy){
            const nearest = findNearestEnemy(u);
            if(nearest){
                const enemyDist = Math.hypot(u.x - nearest.x, u.y - nearest.y);
                if(enemyDist <= COMBAT_AGGRO_RADIUS){
                    u.targetEnemy = nearest;
                }
            }
        }

        if(u.targetEnemy){
    const enemy = players[u.targetEnemy.sid].units[u.targetEnemy.idx];
    if(!enemy || enemy.hp <= 0){
        u.targetEnemy = null;
        u.anim = "idle"; // reset animation
        u.frame = 0;
        continue;
    }

    const edx = enemy.x - u.x;
    const edy = enemy.y - u.y;
    const edist = Math.hypot(edx, edy);

    if(edist > UNIT_ATTACK_RANGE && edist <= COMBAT_AGGRO_RADIUS){
        // Move slower towards enemy
        const moveSpeed = 1.2;
        u.tx = enemy.x;
        u.ty = enemy.y;
        u.x += (edx / edist) * moveSpeed;
        u.y += (edy / edist) * moveSpeed;

        u.anim = "walk";
        u.dir = getDirKey(edx, edy);
    } else if(edist <= UNIT_ATTACK_RANGE){
        u.anim = "attack";
        u.attackFrame += ANIM_SPEED;
        if(u.attackFrame >= ATTACK_ANIM_FRAMES) u.attackFrame = 0;

        if(u.attackCooldown >= ATTACK_COOLDOWN){
            socket.emit("attack_unit", {
                targetSid: u.targetEnemy.sid,
                targetIdx: u.targetEnemy.idx,
                damage: UNIT_ATTACK_DPS / 60
            });
            u.attackCooldown = 0;
        }
    } else {
        // Enemy out of aggro â†’ stop chasing
        u.targetEnemy = null;
        u.anim = "idle"; // ðŸ”¹ reset to idle
        u.frame = 0;
    }
} else {
    // No target and not moving manually â†’ ensure idle
    if(!u.manualMove && u.anim !== "idle"){
        u.anim = "idle";
        u.frame = 0;
    }
}

    }
}

for(const u of myUnits){
    if(u.attackCooldown < ATTACK_COOLDOWN) u.attackCooldown += 16.66; // assuming 60fps ~16.66ms per frame

    if(u.targetEnemy){
        const enemy = players[u.targetEnemy.sid].units[u.targetEnemy.idx];
        if(!enemy || enemy.hp <= 0) continue;

        const edx = enemy.x - u.x;
        const edy = enemy.y - u.y;
        const edist = Math.hypot(edx, edy);

        if(edist <= UNIT_ATTACK_RANGE){
            u.anim = "attack";

            if(u.attackCooldown >= ATTACK_COOLDOWN){
                socket.emit("attack_unit", {
                    targetSid: u.targetEnemy.sid,
                    targetIdx: u.targetEnemy.idx,
                    damage: UNIT_ATTACK_DPS / 60
                });
                u.attackCooldown = 0;
            }
        }
    }
}


socket.on("unit_hp_update", data => {
    const { sid, idx, hp } = data;
    let playerUnits;

    if (sid === mySid) {
        playerUnits = myUnits;   // your own units
    } else {
        playerUnits = otherPlayers[sid]?.units;
    }

    if (playerUnits && playerUnits[idx]) {
        playerUnits[idx].hp = hp;  // update from server
    }
});


// After combat loop, clean up dead units



      // --- Update frame for walk ---
      if(u.anim === "walk"){
          u.frame += ANIM_SPEED;
          if(u.frame >= WALK_FRAMES) u.frame = 0;
      }

      // --- Collision ---
      applyCollisions(u);

      u.lastX = u.x;
      u.lastY = u.y;
  }

  // ===== SEND STATE TO SERVER =====
  socket.emit("update",{x:myUnits[0].x,y:myUnits[0].y});
  const unitStates = myUnits.map(u => ({
    x: u.x,
    y: u.y,
    anim: u.anim,
    frame: u.frame,
    dir: u.dir,
    attackFrame: u.attackFrame
  }));
  socket.emit("update_units", { units: unitStates });




}


// Update all myUnits
const unitStates = myUnits.map(u => ({
  x: u.x,
  y: u.y,
  anim: u.anim,
  frame: u.frame,
  dir: u.dir
}));

socket.emit("update_units", { units: unitStates });

  socket.on("unit_hp_update", (data) => {
    const { sid, idx, hp } = data;
    if (players[sid] && players[sid].units[idx]) {
        players[sid].units[idx].hp = hp;
    }
});


/* ================= BACKGROUND ================= */
function drawBackground(){
  const cx=canvas.width/2;
  const cy=canvas.height/2;
  const baseCol=Math.floor(camera.x/HALF_W);
  const baseRow=Math.floor(camera.y/HALF_H);
  const range=4;

  for(let r=-range;r<=range;r++){
    for(let c=-range;c<=range;c++){
      const col=baseCol+c;
      const row=baseRow+r;
      const wx=(col-row)*HALF_W;
      const wy=(col+row)*HALF_H;
      ctx.drawImage(tile, cx+wx-camera.x, cy+wy-camera.y);
    }
  }
}

/* ================= DRAW ================= */
const buildingImg = new Image();
buildingImg.src = "static/building.png";
const BUILD_W = 506;
const BUILD_H = 370;

function draw() {
  update();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background
  drawBackground();

  // Draw resources
  for (const r of resources) {
    const x = canvas.width / 2 + r.x - camera.x;
    const y = canvas.height / 2 + r.y - camera.y;
    ctx.drawImage(resourceImg, x - RES_W / 2, y - RES_H / 2, RES_W, RES_H);
  }

  // Draw harvesting progress
  if (harvesting) {
    const r = resources.find(r => r.id === harvesting.resourceId);
    if (r) {
      const progress = Math.min(1, (performance.now() - harvesting.startTime) / HARVEST_TIME);
      const x = canvas.width / 2 + r.x - camera.x;
      const y = canvas.height / 2 + r.y - camera.y - 40;

      ctx.fillStyle = "black";
      ctx.fillRect(x - 30, y, 60, 6);
      ctx.fillStyle = "lime";
      ctx.fillRect(x - 30, y, 60 * progress, 6);
    }
  }


// Draw trees (depth-sorted)
const visibleTrees = trees.slice().sort((a, b) => a.y - b.y);

for (const t of visibleTrees) {
  const x = canvas.width / 2 + t.x - camera.x;
  const y = canvas.height / 2 + t.y - camera.y;

  ctx.drawImage(
    treeImg,
    x - TREE_W / 2,
    y - TREE_H,
    TREE_W,
    TREE_H
  );
}
  

// Animate and draw other players
for (const sid in players) {
    if (sid === mySid) continue;
    const p = players[sid];

    for (const u of p.units) {
        // Initialize local animation frames if missing
        if (u.frame === undefined) u.frame = 0;
        if (u.attackFrame === undefined) u.attackFrame = 0;

        let frames, framesShadow;

        if (u.anim === "walk") {
            frames = playerSprites.walk[u.dir];
            framesShadow = playerSprites.walkshadow[u.dir];
            u.frame += ANIM_SPEED;
            if (u.frame >= WALK_FRAMES) u.frame = 0;
        } else if (u.anim === "idle") {
            frames = playerSprites.idle[u.dir];
            framesShadow = playerSprites.idleshadow[u.dir];
            u.frame += ANIM_SPEED;
            if (u.frame >= IDLE_FRAMES) u.frame = 0;
        } else if (u.anim === "attack") {
            frames = playerSprites.attack[u.dir];
            framesShadow = playerSprites.attackshadow[u.dir];
            u.attackFrame += ANIM_SPEED;
            if (u.attackFrame >= ATTACK_ANIM_FRAMES) u.attackFrame = 0;
        } else {
            frames = playerSprites.idle[u.dir];
            framesShadow = playerSprites.idleshadow[u.dir];
        }
      


        const img = frames[u.anim === "attack" ? Math.floor(u.attackFrame) : Math.floor(u.frame)];
        const imgShadow = framesShadow[u.anim === "attack" ? Math.floor(u.attackFrame) : Math.floor(u.frame)];

        const x = canvas.width/2 + u.x - camera.x;
        const y = canvas.height/2 + u.y - camera.y;

        if(imgShadow && imgShadow.complete) ctx.drawImage(imgShadow, x-SPRITE_W/2, y-SPRITE_H/2, SPRITE_W, SPRITE_H);
        if(img && img.complete) ctx.drawImage(img, x-SPRITE_W/2, y-SPRITE_H/2, SPRITE_W, SPRITE_H);

        // Draw health
        const barWidth = 40;
        const barHeight = 5;
        const hpPercent = u.hp / 100;
        ctx.fillStyle = "red";
        ctx.fillRect(x - barWidth/2, y - 30, barWidth, barHeight);
        ctx.fillStyle = "green";
        ctx.fillRect(x - barWidth/2, y - 30, barWidth * hpPercent, barHeight);
    }
}




  // Draw my units
for (const u of myUnits) {
    const x = canvas.width / 2 + u.x - camera.x;
    const y = canvas.height / 2 + u.y - camera.y;

    let frames, framesShadow;
    if(u.anim === "walk"){
        frames = playerSprites.walk[u.dir];
        framesShadow = playerSprites.walkshadow[u.dir];
        u.frame += ANIM_SPEED;
        if(u.frame >= WALK_FRAMES) u.frame = 0;
    } else if(u.anim === "idle"){
        frames = playerSprites.idle[u.dir];
        framesShadow = playerSprites.idleshadow[u.dir];
        u.frame += ANIM_SPEED;
        if(u.frame >= IDLE_FRAMES) u.frame = 0;
    } else if(u.anim === "attack"){
        frames = playerSprites.attack[u.dir];
        framesShadow = playerSprites.attackshadow[u.dir];
        u.attackFrame += ANIM_SPEED;
        if(u.attackFrame >= ATTACK_ANIM_FRAMES) u.attackFrame = 0;
    } else {
        frames = playerSprites.idle[u.dir];
        framesShadow = playerSprites.idleshadow[u.dir];
    }

    const img = frames[u.anim === "attack" ? Math.floor(u.attackFrame) : Math.floor(u.frame)];
    const imgShadow = framesShadow[u.anim === "attack" ? Math.floor(u.attackFrame) : Math.floor(u.frame)];

    if (imgShadow && imgShadow.complete) ctx.drawImage(imgShadow, x - SPRITE_W/2, y - SPRITE_H/2, SPRITE_W, SPRITE_H);
    if (img && img.complete) ctx.drawImage(img, x - SPRITE_W/2, y - SPRITE_H/2, SPRITE_W, SPRITE_H);

    // Draw health, selection, name etc..

    const barWidth = 40;
    const barHeight = 5;
    const hpPercent = u.hp / 100;
    ctx.fillStyle = "red";
    ctx.fillRect(x - barWidth/2, y - 30, barWidth, barHeight);
    ctx.fillStyle = "green";
    ctx.fillRect(x - barWidth/2, y - 30, barWidth * hpPercent, barHeight);

    ctx.fillStyle = "white";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.fillText("YOU", x, y - 40);

    // Selection circle
    if (u.selected) {
      ctx.strokeStyle = "yellow";
      ctx.beginPath();
      ctx.arc(x, y + SPRITE_H / 4, 18, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Draw buildings **on top of units**
  for (const b of buildings) {
    const bx = canvas.width / 2 + b.x - camera.x;
    const by = canvas.height / 2 + b.y - camera.y;

    ctx.drawImage(buildingImg, bx - BUILD_W / 2, by - BUILD_H / 2, BUILD_W, BUILD_H);

    if (b.selected) {
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(bx - BUILD_W / 2, by - BUILD_H / 2, BUILD_W, BUILD_H);
      ctx.setLineDash([]);
    }
  }

  // Hover outline for resource
  if (hoveredResource) {
    const x = canvas.width / 2 + hoveredResource.x - camera.x;
    const y = canvas.height / 2 + hoveredResource.y - camera.y;

    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, RESOURCE_RADIUS, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Hover outline for other players
  if (hoveredPlayerSid && players[hoveredPlayerSid]) {
    const p = players[hoveredPlayerSid];
    const x = canvas.width / 2 + p.x - camera.x;
    const y = canvas.height / 2 + p.y - camera.y;

    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.rect(x - 14, y - 14, 28, 28);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Draw building placement preview
  if (buildMode) {
    ctx.globalAlpha = 0.5;
    const wx = camera.x + mouse.x - canvas.width / 2;
    const wy = camera.y + mouse.y - canvas.height / 2;
    const bx = canvas.width / 2 + wx - camera.x;
    const by = canvas.height / 2 + wy - camera.y;
    ctx.drawImage(buildingImg, bx - BUILD_W / 2, by - BUILD_H / 2, BUILD_W, BUILD_H);
    ctx.globalAlpha = 1;
  }

  // Draw selection box
  if (selecting) {
    ctx.strokeStyle = "white";
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(selectStart.x, selectStart.y, mouse.x - selectStart.x, mouse.y - selectStart.y);
    ctx.setLineDash([]);
  }

  // Update panels
  const selectedBuilding = buildings.find(b => b.selected);
  const selectedUnits = myUnits.filter(u => u.selected);

  if (selectedBuilding) {
    buildingPanel.style.display = "block";
    panel.style.display = "none";
  } else if (selectedUnits.length > 0) {
    panel.style.display = "block";
    buildingPanel.style.display = "none";
  } else {
    panel.style.display = "none";
    buildingPanel.style.display = "none";
  }

if(DEBUG_COLLISIONS){
    for(const u of myUnits){
        applyCollisions(u); // only for drawing, don't push
    }
}



  // Update HUD
  hud.innerText = `Camera: ${camera.x|0}, ${camera.y|0}
Resources: ${resourceCount}
Selected: ${selectedUnits.length}`;

  requestAnimationFrame(draw);
}


tile.onload = draw;
</script>
</body>
</html>
